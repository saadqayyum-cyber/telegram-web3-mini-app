{"version":3,"file":"static/js/4825.98706faf.chunk.js","mappings":"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","sources":["../node_modules/@thirdweb-dev/sdk/dist/QueryParams-32a56510.browser.esm.js","../node_modules/@thirdweb-dev/sdk/dist/contract-owner-49e75547.browser.esm.js"],"sourcesContent":["import { a as CommonNFTOutput, C as CommonNFTInput } from './setErc20Allowance-7f76f677.browser.esm.js';\nimport { utils, BigNumber, Contract } from 'ethers';\nimport 'zod';\n\n/**\n * @internal\n */\n\n/**\n * @internal\n */\nconst InterfaceId_IERC721 = /* @__PURE__ */(() => utils.arrayify(\"0x80ac58cd\"))();\n\n/**\n * @internal\n */\nconst InterfaceId_IERC1155 = /* @__PURE__ */(() => utils.arrayify(\"0xd9b67a26\"))();\n\nconst FALLBACK_METADATA = {\n  name: \"Failed to load NFT metadata\"\n};\n\n/**\n * fetches the token metadata\n * @param tokenId - the id (to get it back in the output)\n * @param tokenUri - the uri to fetch\n * @param storage - which storage to fetch from\n *\n * @internal\n */\nasync function fetchTokenMetadata(tokenId, tokenUri, storage) {\n  // check for base64 encoded JSON\n  if (tokenUri.startsWith(\"data:application/json;base64\") && typeof Buffer !== \"undefined\") {\n    const base64 = tokenUri.split(\",\")[1];\n    const jsonMetadata = JSON.parse(Buffer.from(base64, \"base64\").toString(\"utf-8\"));\n    return CommonNFTOutput.parse({\n      ...jsonMetadata,\n      id: BigNumber.from(tokenId).toString(),\n      uri: tokenUri\n    });\n  }\n  // handle dynamic id URIs (2 possible formats)\n  const parsedUri = tokenUri.replace(\"{id}\", utils.hexZeroPad(BigNumber.from(tokenId).toHexString(), 32).slice(2));\n  let jsonMetadata;\n  try {\n    jsonMetadata = await storage.downloadJSON(parsedUri);\n  } catch (err) {\n    const unparsedTokenIdUri = tokenUri.replace(\"{id}\", BigNumber.from(tokenId).toString());\n    try {\n      jsonMetadata = await storage.downloadJSON(unparsedTokenIdUri);\n    } catch (e) {\n      console.warn(`failed to get token metadata: ${JSON.stringify({\n        tokenId: tokenId.toString(),\n        tokenUri\n      })} -- falling back to default metadata`);\n      jsonMetadata = FALLBACK_METADATA;\n    }\n  }\n  return CommonNFTOutput.parse({\n    ...jsonMetadata,\n    id: BigNumber.from(tokenId).toString(),\n    uri: tokenUri\n  });\n}\n\n// Used for marketplace to fetch NFT metadata from contract address + tokenId\n/**\n * @internal\n * @param contractAddress - the contract address\n * @param provider - the provider to use\n * @param tokenId - the token id\n * @param storage - the storage to use\n */\nasync function fetchTokenMetadataForContract(contractAddress, provider, tokenId, storage) {\n  let uri;\n  const ERC165MetadataAbi = (await import('@thirdweb-dev/contracts-js/dist/abis/IERC165.json')).default;\n  const erc165 = new Contract(contractAddress, ERC165MetadataAbi, provider);\n  const [isERC721, isERC1155] = await Promise.all([erc165.supportsInterface(InterfaceId_IERC721), erc165.supportsInterface(InterfaceId_IERC1155)]);\n  if (isERC721) {\n    const ERC721MetadataAbi = (await import('@thirdweb-dev/contracts-js/dist/abis/IERC721Metadata.json')).default;\n    const erc721 = new Contract(contractAddress, ERC721MetadataAbi, provider);\n    uri = await erc721.tokenURI(tokenId);\n  } else if (isERC1155) {\n    const ERC1155MetadataAbi = (await import('@thirdweb-dev/contracts-js/dist/abis/IERC1155Metadata.json')).default;\n    const erc1155 = new Contract(contractAddress, ERC1155MetadataAbi, provider);\n    uri = await erc1155.uri(tokenId);\n  } else {\n    throw Error(\"Contract must implement ERC 1155 or ERC 721.\");\n  }\n  if (!uri) {\n    // no uri found, return fallback metadata\n    return CommonNFTOutput.parse({\n      ...FALLBACK_METADATA,\n      id: BigNumber.from(tokenId).toString(),\n      uri: \"\"\n    });\n  }\n  return fetchTokenMetadata(tokenId, uri, storage);\n}\n\n/**\n * @internal\n * @param metadata - the metadata to upload\n * @param storage - the storage to use\n */\nasync function uploadOrExtractURI(metadata, storage) {\n  if (typeof metadata === \"string\") {\n    return metadata;\n  } else {\n    return await storage.upload(CommonNFTInput.parse(metadata));\n  }\n}\n\n/**\n * @internal\n * @param metadatas - the metadata to upload\n * @param storage - the storage to use\n * @param startNumber - the number to start the file names at\n * @param contractAddress - the contract address\n * @param signerAddress - the signer address\n * @param options - options\n */\nasync function uploadOrExtractURIs(metadatas, storage, startNumber, options) {\n  if (isUriList(metadatas)) {\n    return metadatas;\n  } else if (isMetadataList(metadatas)) {\n    const uris = await storage.uploadBatch(metadatas.map(m => CommonNFTInput.parse(m)), {\n      rewriteFileNames: {\n        fileStartNumber: startNumber || 0\n      },\n      onProgress: options?.onProgress\n    });\n    return uris;\n  } else {\n    throw new Error(\"NFT metadatas must all be of the same type (all URI or all NFTMetadataInput)\");\n  }\n}\nfunction getBaseUriFromBatch(uris) {\n  const baseUri = uris[0].substring(0, uris[0].lastIndexOf(\"/\"));\n  for (let i = 0; i < uris.length; i++) {\n    const uri = uris[i].substring(0, uris[i].lastIndexOf(\"/\"));\n    if (baseUri !== uri) {\n      throw new Error(`Can only create batches with the same base URI for every entry in the batch. Expected '${baseUri}' but got '${uri}'`);\n    }\n  }\n\n  // Ensure that baseUri ends with trailing slash\n  return baseUri.replace(/\\/$/, \"\") + \"/\";\n}\nfunction isUriList(metadatas) {\n  return metadatas.find(m => typeof m !== \"string\") === undefined;\n}\nfunction isMetadataList(metadatas) {\n  return metadatas.find(m => typeof m !== \"object\") === undefined;\n}\n\n/**\n * @internal\n */\nconst DEFAULT_QUERY_ALL_COUNT = 100;\n\n/**\n * Pagination Parameters\n * @public\n */\n\nexport { DEFAULT_QUERY_ALL_COUNT as D, FALLBACK_METADATA as F, InterfaceId_IERC721 as I, InterfaceId_IERC1155 as a, uploadOrExtractURI as b, fetchTokenMetadataForContract as c, fetchTokenMetadata as f, getBaseUriFromBatch as g, uploadOrExtractURIs as u };\n","import { h as hasFunction } from './contract-appuri-5c40af52.browser.esm.js';\nimport { f as buildTransactionFunction, T as Transaction } from './transactions-72f9603c.browser.esm.js';\nimport { d5 as FEATURE_ROYALTY, bF as CommonRoyaltySchema, aV as NATIVE_TOKEN_ADDRESS, d6 as FEATURE_OWNER, aL as resolveAddress } from './index-33cd3415.browser.esm.js';\nimport { C as ContractEncoder } from './fetchCurrencyValue-32d08b05.browser.esm.js';\nimport { utils, BigNumber, Contract } from 'ethers';\nimport { C as CommonNFTInput } from './setErc20Allowance-7f76f677.browser.esm.js';\nimport { c as fetchTokenMetadataForContract, g as getBaseUriFromBatch } from './QueryParams-32a56510.browser.esm.js';\nimport { a as approveErc20Allowance } from './signature-d3ea643d.browser.esm.js';\nimport { n as normalizePriceValue } from './normalizePriceValue-9851c0eb.browser.esm.js';\n\n/**\n * Handle contract royalties\n * @remarks Configure royalties for an entire contract or a particular token.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * const royaltyInfo = await contract.royalties.getDefaultRoyaltyInfo();\n * await contract.roles.setTokenRoyaltyInfo(tokenId, {\n *   seller_fee_basis_points: 100, // 1% royalty fee\n *   fee_recipient: \"0x...\", // the fee recipient\n * });\n * ```\n * @public\n */\nclass ContractRoyalty {\n  featureName = FEATURE_ROYALTY.name;\n  constructor(contractWrapper, metadata) {\n    this.contractWrapper = contractWrapper;\n    this.metadata = metadata;\n  }\n\n  /**\n   * Get the royalty recipient and fee\n   * @returns  The royalty recipient and BPS\n   * @example\n   * ```javascript\n   * const royaltyInfo = await contract.royalties.getDefaultRoyaltyInfo();\n   * console.log(royaltyInfo.fee_recipient);\n   * console.log(royaltyInfo.seller_fee_basis_points);\n   * ```\n   * @public\n   * @twfeature Royalty\n   */\n  async getDefaultRoyaltyInfo() {\n    const [royaltyRecipient, royaltyBps] = await this.contractWrapper.read(\"getDefaultRoyaltyInfo\", []);\n    // parse it on the way out to make sure we default things if they are not set\n    return CommonRoyaltySchema.parseAsync({\n      fee_recipient: royaltyRecipient,\n      seller_fee_basis_points: royaltyBps\n    });\n  }\n\n  /**\n   * Get the royalty recipient and fee of a particular token\n   * @returns  The royalty recipient and BPS\n   * @example\n   * ```javascript\n   * const royaltyInfo = await contract.royalties.getDefaultRoyaltyInfo();\n   * console.log(royaltyInfo.fee_recipient);\n   * console.log(royaltyInfo.seller_fee_basis_points);\n   * ```\n   * @public\n   * @twfeature Royalty\n   */\n  async getTokenRoyaltyInfo(tokenId) {\n    const [royaltyRecipient, royaltyBps] = await this.contractWrapper.read(\"getRoyaltyInfoForToken\", [tokenId]);\n    return CommonRoyaltySchema.parseAsync({\n      fee_recipient: royaltyRecipient,\n      seller_fee_basis_points: royaltyBps\n    });\n  }\n\n  /**\n   * Set the royalty recipient and fee\n   * @param royaltyData - the royalty recipient and fee\n   *  @example\n   * ```javascript\n   * await contract.roles.setDefaultRoyaltyInfo({\n   *   seller_fee_basis_points: 100, // 1% royalty fee\n   *   fee_recipient: \"0x...\", // the fee recipient\n   * });\n   * ```\n   * @public\n   * @twfeature Royalty\n   */\n  setDefaultRoyaltyInfo = /* @__PURE__ */buildTransactionFunction(async royaltyData => {\n    // read the metadata from the contract\n    const oldMetadata = await this.metadata.get();\n\n    // update the metadata with the new royalty data\n    // if one of the keys is \"undefined\" it will be ignored (which is the desired behavior)\n    const mergedMetadata = await this.metadata.parseInputMetadata({\n      ...oldMetadata,\n      ...royaltyData\n    });\n\n    // why not use this.metadata.set()? - because that would end up sending it's own separate transaction to `setContractURI`\n    // but we want to send both the `setRoyaltyInfo` and `setContractURI` in one transaction!\n    const contractURI = await this.metadata._parseAndUploadMetadata(mergedMetadata);\n    if (hasFunction(\"setContractURI\", this.contractWrapper)) {\n      const contractEncoder = new ContractEncoder(this.contractWrapper);\n      // encode both the functions we want to send\n      const encoded = [contractEncoder.encode(\"setDefaultRoyaltyInfo\", [mergedMetadata.fee_recipient, mergedMetadata.seller_fee_basis_points]), contractEncoder.encode(\"setContractURI\", [contractURI])];\n      // actually send the transaction and return the receipt + a way to get the new royalty info\n\n      return Transaction.fromContractWrapper({\n        contractWrapper: this.contractWrapper,\n        method: \"multicall\",\n        args: [encoded],\n        parse: receipt => ({\n          receipt,\n          data: () => this.getDefaultRoyaltyInfo()\n        })\n      });\n    } else {\n      throw new Error(\"Updating royalties requires implementing ContractMetadata in your contract to support marketplaces like OpenSea.\");\n    }\n  });\n\n  /**\n   * Set the royalty recipient and fee for a particular token\n   * @param tokenId - the token id\n   * @param royaltyData - the royalty recipient and fee\n   * @example\n   * ```javascript\n   * const tokenId = 0;\n   * await contract.roles.setTokenRoyaltyInfo(tokenId, {\n   *   seller_fee_basis_points: 100, // 1% royalty fee\n   *   fee_recipient: \"0x...\", // the fee recipient\n   * });\n   * ```\n   * @public\n   * @twfeature Royalty\n   */\n  setTokenRoyaltyInfo = /* @__PURE__ */buildTransactionFunction(async (tokenId, royaltyData) => {\n    const parsedRoyaltyData = CommonRoyaltySchema.parse(royaltyData);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"setRoyaltyInfoForToken\",\n      args: [tokenId, parsedRoyaltyData.fee_recipient, parsedRoyaltyData.seller_fee_basis_points],\n      parse: receipt => ({\n        receipt,\n        data: () => this.getDefaultRoyaltyInfo()\n      })\n    });\n  });\n}\n\n/**\n * Handles delayed reveal logic\n * @public\n */\nclass DelayedReveal {\n  constructor(contractWrapper, storage, featureName, nextTokenIdToMintFn) {\n    this.featureName = featureName;\n    this.nextTokenIdToMintFn = nextTokenIdToMintFn;\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n  }\n\n  /**\n   * Create a batch of encrypted NFTs that can be revealed at a later time.\n   * @remarks Create a batch of encrypted NFTs that can be revealed at a later time.\n   * @example\n   * ```javascript\n   * // the real NFTs, these will be encrypted until your reveal them!\n   * const realNFTs = [{\n   *   name: \"Common NFT #1\",\n   *   description: \"Common NFT, one of many.\",\n   *   image: fs.readFileSync(\"path/to/image.png\"),\n   * }, {\n   *   name: \"Super Rare NFT #2\",\n   *   description: \"You got a Super Rare NFT!\",\n   *   image: fs.readFileSync(\"path/to/image.png\"),\n   * }];\n   * // A placeholder NFT that people will get immediately in their wallet, until the reveal happens!\n   * const placeholderNFT = {\n   *   name: \"Hidden NFT\",\n   *   description: \"Will be revealed next week!\"\n   * };\n   * // Create and encrypt the NFTs\n   * await contract.revealer.createDelayedRevealBatch(\n   *   placeholderNFT,\n   *   realNFTs,\n   *   \"my secret password\",\n   * );\n   * ```\n   * @public\n   * @param placeholder - the placeholder NFT to show before the reveal\n   * @param metadatas - the final NFTs that will be hidden\n   * @param password - the password that will be used to reveal these NFTs\n   * @param options - additional options like upload progress\n   */\n  createDelayedRevealBatch = /* @__PURE__ */buildTransactionFunction(async (placeholder, metadatas, password, options) => {\n    if (!password) {\n      throw new Error(\"Password is required\");\n    }\n    const placeholderUris = await this.storage.uploadBatch([CommonNFTInput.parse(placeholder)], {\n      rewriteFileNames: {\n        fileStartNumber: 0\n      }\n    });\n    const placeholderUri = getBaseUriFromBatch(placeholderUris);\n    const startFileNumber = await this.nextTokenIdToMintFn();\n    const uris = await this.storage.uploadBatch(metadatas.map(m => CommonNFTInput.parse(m)), {\n      onProgress: options?.onProgress,\n      rewriteFileNames: {\n        fileStartNumber: startFileNumber.toNumber()\n      }\n    });\n    const baseUri = getBaseUriFromBatch(uris);\n    const baseUriId = await this.contractWrapper.read(\"getBaseURICount\", []);\n    const hashedPassword = await this.hashDelayRevealPassword(baseUriId, password);\n    const encryptedBaseUri = await this.contractWrapper.read(\"encryptDecrypt\", [utils.toUtf8Bytes(baseUri), hashedPassword]);\n    let data;\n    const legacyContract = await this.isLegacyContract();\n    if (legacyContract) {\n      data = encryptedBaseUri;\n    } else {\n      const chainId = await this.contractWrapper.getChainID();\n      const provenanceHash = utils.solidityKeccak256([\"bytes\", \"bytes\", \"uint256\"], [utils.toUtf8Bytes(baseUri), hashedPassword, chainId]);\n      data = utils.defaultAbiCoder.encode([\"bytes\", \"bytes32\"], [encryptedBaseUri, provenanceHash]);\n    }\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"lazyMint\",\n      args: [uris.length, placeholderUri.endsWith(\"/\") ? placeholderUri : `${placeholderUri}/`, data],\n      parse: receipt => {\n        const events = this.contractWrapper.parseLogs(\"TokensLazyMinted\", receipt?.logs);\n        const startingIndex = events[0].args.startTokenId;\n        const endingIndex = events[0].args.endTokenId;\n        const results = [];\n        for (let id = startingIndex; id.lte(endingIndex); id = id.add(1)) {\n          results.push({\n            id,\n            receipt\n          });\n        }\n        return results;\n      }\n    });\n  });\n\n  /**\n   * Reveal a batch of hidden NFTs\n   * @remarks Reveal the NFTs of a batch using the password.\n   * @example\n   * ```javascript\n   * // the batch to reveal\n   * const batchId = 0;\n   * // reveal the batch\n   * await contract.revealer.reveal(batchId, \"my secret password\");\n   * ```\n   * @public\n   * @param batchId - the id of the batch to reveal\n   * @param password - the password\n   */\n  reveal = /* @__PURE__ */buildTransactionFunction(async (batchId, password) => {\n    if (!password) {\n      throw new Error(\"Password is required\");\n    }\n    const key = await this.hashDelayRevealPassword(batchId, password);\n    // performing the reveal locally to make sure it'd succeed before sending the transaction\n    try {\n      const decryptedUri = await this.contractWrapper.callStatic().reveal(batchId, key);\n      // basic sanity check for making sure decryptedUri is valid\n      // this is optional because invalid decryption key would result in non-utf8 bytes and\n      // ethers would throw when trying to decode it\n      if (!decryptedUri.includes(\"://\") || !decryptedUri.endsWith(\"/\")) {\n        throw new Error(\"invalid password\");\n      }\n    } catch (e) {\n      throw new Error(\"invalid password\");\n    }\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"reveal\",\n      args: [batchId, key]\n    });\n  });\n\n  /**\n   * Gets the list of unrevealed NFT batches.\n   * @remarks Gets the list of unrevealed NFT batches.\n   * @example\n   * ```javascript\n   * const batches = await contract.revealer.getBatchesToReveal();\n   * ```\n   * @public\n   */\n  async getBatchesToReveal() {\n    const count = await this.contractWrapper.read(\"getBaseURICount\", []);\n    if (count.isZero()) {\n      return [];\n    }\n    const countRangeArray = Array.from(Array(count.toNumber()).keys());\n    // map over to get the base uri indices, which should be the end token id of every batch\n    const uriIndices = await Promise.all(countRangeArray.map(i => {\n      if (hasFunction(\"getBatchIdAtIndex\", this.contractWrapper)) {\n        return this.contractWrapper.read(\"getBatchIdAtIndex\", [i]);\n      }\n      if (hasFunction(\"baseURIIndices\", this.contractWrapper)) {\n        return this.contractWrapper.read(\"baseURIIndices\", [i]);\n      }\n      throw new Error(\"Contract does not have getBatchIdAtIndex or baseURIIndices.\");\n    }));\n\n    // first batch always start from 0. don't need to fetch the last batch so pop it from the range array\n    const uriIndicesWithZeroStart = uriIndices.slice(0, uriIndices.length - 1);\n\n    // returns the token uri for each batches. first batch always starts from token id 0.\n    const tokenMetadatas = await Promise.all(Array.from([0, ...uriIndicesWithZeroStart]).map(i => this.getNftMetadata(i.toString())));\n\n    // index is the uri indices, which is end token id. different from uris\n    const legacyContract = await this.isLegacyContract();\n    const encryptedUriData = await Promise.all(Array.from([...uriIndices]).map(i => legacyContract ? this.getLegacyEncryptedData(i) : this.contractWrapper.read(\"encryptedData\", [i])));\n    const encryptedBaseUris = encryptedUriData.map(data => {\n      if (utils.hexDataLength(data) > 0) {\n        if (legacyContract) {\n          return data;\n        }\n        const result = utils.defaultAbiCoder.decode([\"bytes\", \"bytes32\"], data);\n        return result[0];\n      } else {\n        return data;\n      }\n    });\n    return tokenMetadatas.map((meta, index) => ({\n      batchId: BigNumber.from(index),\n      batchUri: meta.uri,\n      placeholderMetadata: meta\n    })).filter((_, index) => utils.hexDataLength(encryptedBaseUris[index]) > 0);\n  }\n\n  /**\n   * Algorithm to hash delay reveal password, so we don't broadcast the input password on-chain.\n   *\n   * @internal\n   */\n  async hashDelayRevealPassword(batchTokenIndex, password) {\n    const chainId = await this.contractWrapper.getChainID();\n    const contractAddress = this.contractWrapper.address;\n    return utils.solidityKeccak256([\"string\", \"uint256\", \"uint256\", \"address\"], [password, chainId, batchTokenIndex, contractAddress]);\n  }\n  async getNftMetadata(tokenId) {\n    return fetchTokenMetadataForContract(this.contractWrapper.address, this.contractWrapper.getProvider(), tokenId, this.storage);\n  }\n  async isLegacyContract() {\n    if (hasFunction(\"contractVersion\", this.contractWrapper)) {\n      try {\n        const version = await this.contractWrapper.read(\"contractVersion\", []);\n        return version <= 2;\n      } catch (e) {\n        return false;\n      }\n    }\n    return false;\n  }\n  async getLegacyEncryptedData(index) {\n    const DeprecatedAbi = (await import('@thirdweb-dev/contracts-js/dist/abis/IDelayedRevealDeprecated.json')).default;\n    const legacy = new Contract(this.contractWrapper.address, DeprecatedAbi, this.contractWrapper.getProvider());\n    const result = await legacy.functions[\"encryptedBaseURI\"](index);\n    if (result.length > 0) {\n      return result[0];\n    } else {\n      return \"0x\";\n    }\n  }\n}\n\nasync function calculateClaimCost(contractWrapper, pricePerToken, quantity, currencyAddress, checkERC20Allowance) {\n  let overrides = {};\n  const currency = currencyAddress || NATIVE_TOKEN_ADDRESS;\n  const normalizedPrice = await normalizePriceValue(contractWrapper.getProvider(), pricePerToken, currency);\n  const totalCost = normalizedPrice.mul(quantity);\n  if (totalCost.gt(0)) {\n    if (currency === NATIVE_TOKEN_ADDRESS) {\n      overrides = {\n        value: totalCost\n      };\n    } else if (currency !== NATIVE_TOKEN_ADDRESS && checkERC20Allowance) {\n      await approveErc20Allowance(contractWrapper, currency, totalCost, quantity, 0);\n    }\n  }\n  return overrides;\n}\n\n/**\n * Encodes and decodes Contract functions\n * @public\n */\nclass ContractOwner {\n  featureName = FEATURE_OWNER.name;\n  constructor(contractWrapper) {\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * Get the current owner of the contract\n   * @example\n   * ```javascript\n   * await contract.owner.get();\n   * console.log(\"Owner address: \", ownerAddress);\n   * ```\n   * @returns The owner address\n   * @twfeature Ownable\n   */\n  async get() {\n    return this.contractWrapper.read(\"owner\", []);\n  }\n\n  /**\n   * Set the new owner of the contract\n   * @remarks Can only be called by the current owner.\n   *\n   * @param address - the address of the new owner\n   *\n   * @example\n   * ```javascript\n   * const newOwnerAddress = \"{{wallet_address}}\";\n   * await contract.owner.set(newOwnerAddress);\n   * ```\n   * @twfeature Ownable\n   */\n  set = /* @__PURE__ */buildTransactionFunction(async address => {\n    const resolvedAddress = await resolveAddress(address);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"setOwner\",\n      args: [resolvedAddress]\n    });\n  });\n}\n\nexport { ContractRoyalty as C, DelayedReveal as D, ContractOwner as a, calculateClaimCost as c };\n"],"names":["InterfaceId_IERC721","utils","InterfaceId_IERC1155","FALLBACK_METADATA","name","async","fetchTokenMetadata","tokenId","tokenUri","storage","startsWith","Buffer","base64","split","jsonMetadata","JSON","parse","from","toString","CommonNFTOutput","id","BigNumber","uri","parsedUri","replace","toHexString","slice","downloadJSON","err","unparsedTokenIdUri","e","console","warn","stringify","fetchTokenMetadataForContract","contractAddress","provider","ERC165MetadataAbi","default","erc165","Contract","isERC721","isERC1155","Promise","all","supportsInterface","ERC721MetadataAbi","erc721","tokenURI","Error","ERC1155MetadataAbi","erc1155","uploadOrExtractURI","metadata","upload","CommonNFTInput","uploadOrExtractURIs","metadatas","startNumber","options","undefined","find","m","isUriList","isMetadataList","uploadBatch","map","rewriteFileNames","fileStartNumber","onProgress","getBaseUriFromBatch","uris","baseUri","substring","lastIndexOf","i","length","DEFAULT_QUERY_ALL_COUNT","ContractRoyalty","featureName","FEATURE_ROYALTY","constructor","contractWrapper","this","getDefaultRoyaltyInfo","royaltyRecipient","royaltyBps","read","CommonRoyaltySchema","parseAsync","fee_recipient","seller_fee_basis_points","getTokenRoyaltyInfo","setDefaultRoyaltyInfo","buildTransactionFunction","oldMetadata","get","mergedMetadata","parseInputMetadata","royaltyData","contractURI","_parseAndUploadMetadata","hasFunction","contractEncoder","ContractEncoder","encoded","encode","Transaction","fromContractWrapper","method","args","receipt","data","setTokenRoyaltyInfo","parsedRoyaltyData","DelayedReveal","nextTokenIdToMintFn","createDelayedRevealBatch","placeholder","password","placeholderUris","placeholderUri","startFileNumber","toNumber","baseUriId","hashedPassword","hashDelayRevealPassword","encryptedBaseUri","isLegacyContract","chainId","getChainID","provenanceHash","endsWith","events","parseLogs","logs","startingIndex","startTokenId","endingIndex","endTokenId","results","lte","add","push","reveal","batchId","key","decryptedUri","callStatic","includes","getBatchesToReveal","count","isZero","countRangeArray","Array","keys","uriIndices","uriIndicesWithZeroStart","tokenMetadatas","getNftMetadata","legacyContract","encryptedBaseUris","getLegacyEncryptedData","decode","meta","index","batchUri","placeholderMetadata","filter","_","batchTokenIndex","address","getProvider","DeprecatedAbi","legacy","result","functions","calculateClaimCost","pricePerToken","quantity","currencyAddress","checkERC20Allowance","overrides","currency","NATIVE_TOKEN_ADDRESS","totalCost","normalizePriceValue","mul","gt","value","approveErc20Allowance","ContractOwner","FEATURE_OWNER","set","resolvedAddress","resolveAddress"],"sourceRoot":""}