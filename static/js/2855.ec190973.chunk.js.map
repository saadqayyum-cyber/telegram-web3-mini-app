{"version":3,"file":"static/js/2855.ec190973.chunk.js","mappings":"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","sources":["../node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/src/utils/promise/withCache.ts","../node_modules/@thirdweb-dev/sdk/node_modules/viem/utils/abi/formatAbiItem.ts","../node_modules/@thirdweb-dev/sdk/node_modules/viem/errors/abi.ts","../node_modules/@thirdweb-dev/sdk/node_modules/viem/utils/lru.ts","../node_modules/@thirdweb-dev/sdk/node_modules/viem/utils/address/getAddress.ts","../node_modules/@thirdweb-dev/sdk/node_modules/viem/errors/cursor.ts","../node_modules/@thirdweb-dev/sdk/node_modules/viem/utils/cursor.ts","../node_modules/@thirdweb-dev/sdk/node_modules/viem/utils/data/trim.ts","../node_modules/@thirdweb-dev/sdk/node_modules/viem/utils/encoding/fromBytes.ts","../node_modules/@thirdweb-dev/sdk/node_modules/viem/utils/abi/encodeAbiParameters.ts","../node_modules/@thirdweb-dev/sdk/node_modules/viem/utils/abi/decodeAbiParameters.ts","../node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/src/rpc/rpc.ts","../node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/src/rpc/fetch-rpc.ts","../node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/src/transaction/read-contract.ts","../node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/src/rpc/actions/eth_call.ts","../node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/src/extensions/erc20/__generated__/IERC20/read/decimals.ts","../node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/src/extensions/erc20/read/decimals.ts"],"sourcesContent":["// copy of: https://github.com/wevm/viem/blob/6cf2c3b5fe608bce9c828af867dfaa65103753a6/src/utils/promise/withCache.ts\n// with slight adjustments made to comply with our linting rules\n// TODO: explore extracting this from viem and instead having a separate general purpose library for this kind of thing\n// alternatively viem could maybe export this helpful util\n// TODO: explore using a LRU cache instead of a Map\n\nconst promiseCache = /*#__PURE__*/ new Map();\nconst responseCache = /*#__PURE__*/ new Map();\n\n/**\n *@internal\n */\nexport function getCache<TData>(cacheKey: string) {\n  const buildCache = <TData>(cacheKey_: string, cache: Map<string, TData>) => ({\n    clear: () => cache.delete(cacheKey_),\n    get: () => cache.get(cacheKey_),\n    set: (data: TData) => cache.set(cacheKey_, data),\n  });\n\n  const promise = buildCache<Promise<TData>>(cacheKey, promiseCache);\n  const response = buildCache<{ created: Date; data: TData }>(\n    cacheKey,\n    responseCache,\n  );\n\n  return {\n    clear: () => {\n      promise.clear();\n      response.clear();\n    },\n    promise,\n    response,\n  };\n}\n\ntype WithCacheParameters = {\n  /** The key to cache the data against. */\n  cacheKey: string;\n  /** The time that cached data will remain in memory. Default: Infinity (no expiry) */\n  cacheTime?: number;\n};\n\n/**\n * Returns the result of a given promise, and caches the result for\n * subsequent invocations against a provided cache key.\n * @internal\n */\nexport async function withCache<TData>(\n  fn: () => Promise<TData>,\n  { cacheKey, cacheTime = Number.POSITIVE_INFINITY }: WithCacheParameters,\n) {\n  const cache = getCache<TData>(cacheKey);\n\n  // If a response exists in the cache, and it's not expired, return it\n  // and do not invoke the promise.\n  // If the max age is 0, the cache is disabled.\n  const response = cache.response.get();\n  if (response && cacheTime > 0) {\n    const age = new Date().getTime() - response.created.getTime();\n    if (age < cacheTime) {\n      return response.data;\n    }\n  }\n\n  let promise = cache.promise.get();\n  if (!promise) {\n    promise = fn();\n\n    // Store the promise in the cache so that subsequent invocations\n    // will wait for the same promise to resolve (deduping).\n    cache.promise.set(promise);\n  }\n\n  try {\n    const data = await promise;\n\n    // Store the response in the cache so that subsequent invocations\n    // will return the same response.\n    cache.response.set({ created: new Date(), data });\n\n    return data;\n  } finally {\n    // Clear the promise cache so that subsequent invocations will\n    // invoke the promise again.\n    cache.promise.clear();\n  }\n}\n","import type { AbiParameter } from 'abitype'\n\nimport {\n  InvalidDefinitionTypeError,\n  type InvalidDefinitionTypeErrorType,\n} from '../../errors/abi.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { AbiItem } from '../../types/contract.js'\n\nexport type FormatAbiItemErrorType =\n  | FormatAbiParamsErrorType\n  | InvalidDefinitionTypeErrorType\n  | ErrorType\n\nexport function formatAbiItem(\n  abiItem: AbiItem,\n  { includeName = false }: { includeName?: boolean | undefined } = {},\n) {\n  if (\n    abiItem.type !== 'function' &&\n    abiItem.type !== 'event' &&\n    abiItem.type !== 'error'\n  )\n    throw new InvalidDefinitionTypeError(abiItem.type)\n\n  return `${abiItem.name}(${formatAbiParams(abiItem.inputs, { includeName })})`\n}\n\nexport type FormatAbiParamsErrorType = ErrorType\n\nexport function formatAbiParams(\n  params: readonly AbiParameter[] | undefined,\n  { includeName = false }: { includeName?: boolean | undefined } = {},\n): string {\n  if (!params) return ''\n  return params\n    .map((param) => formatAbiParam(param, { includeName }))\n    .join(includeName ? ', ' : ',')\n}\n\nexport type FormatAbiParamErrorType = ErrorType\n\nfunction formatAbiParam(\n  param: AbiParameter,\n  { includeName }: { includeName: boolean },\n): string {\n  if (param.type.startsWith('tuple')) {\n    return `(${formatAbiParams(\n      (param as unknown as { components: AbiParameter[] }).components,\n      { includeName },\n    )})${param.type.slice('tuple'.length)}`\n  }\n  return param.type + (includeName && param.name ? ` ${param.name}` : '')\n}\n","import type { Abi, AbiEvent, AbiParameter } from 'abitype'\n\nimport type { Hex } from '../types/misc.js'\nimport { formatAbiItem, formatAbiParams } from '../utils/abi/formatAbiItem.js'\nimport { size } from '../utils/data/size.js'\n\nimport { BaseError } from './base.js'\n\nexport type AbiConstructorNotFoundErrorType = AbiConstructorNotFoundError & {\n  name: 'AbiConstructorNotFoundError'\n}\nexport class AbiConstructorNotFoundError extends BaseError {\n  override name = 'AbiConstructorNotFoundError'\n  constructor({ docsPath }: { docsPath: string }) {\n    super(\n      [\n        'A constructor was not found on the ABI.',\n        'Make sure you are using the correct ABI and that the constructor exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n      },\n    )\n  }\n}\n\nexport type AbiConstructorParamsNotFoundErrorType =\n  AbiConstructorParamsNotFoundError & {\n    name: 'AbiConstructorParamsNotFoundError'\n  }\n\nexport class AbiConstructorParamsNotFoundError extends BaseError {\n  override name = 'AbiConstructorParamsNotFoundError'\n  constructor({ docsPath }: { docsPath: string }) {\n    super(\n      [\n        'Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.',\n        'Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists.',\n      ].join('\\n'),\n      {\n        docsPath,\n      },\n    )\n  }\n}\n\nexport type AbiDecodingDataSizeInvalidErrorType =\n  AbiDecodingDataSizeInvalidError & {\n    name: 'AbiDecodingDataSizeInvalidError'\n  }\nexport class AbiDecodingDataSizeInvalidError extends BaseError {\n  override name = 'AbiDecodingDataSizeInvalidError'\n  constructor({ data, size }: { data: Hex; size: number }) {\n    super(\n      [\n        `Data size of ${size} bytes is invalid.`,\n        'Size must be in increments of 32 bytes (size % 32 === 0).',\n      ].join('\\n'),\n      { metaMessages: [`Data: ${data} (${size} bytes)`] },\n    )\n  }\n}\n\nexport type AbiDecodingDataSizeTooSmallErrorType =\n  AbiDecodingDataSizeTooSmallError & {\n    name: 'AbiDecodingDataSizeTooSmallError'\n  }\nexport class AbiDecodingDataSizeTooSmallError extends BaseError {\n  override name = 'AbiDecodingDataSizeTooSmallError'\n\n  data: Hex\n  params: readonly AbiParameter[]\n  size: number\n\n  constructor({\n    data,\n    params,\n    size,\n  }: { data: Hex; params: readonly AbiParameter[]; size: number }) {\n    super(\n      [`Data size of ${size} bytes is too small for given parameters.`].join(\n        '\\n',\n      ),\n      {\n        metaMessages: [\n          `Params: (${formatAbiParams(params, { includeName: true })})`,\n          `Data:   ${data} (${size} bytes)`,\n        ],\n      },\n    )\n\n    this.data = data\n    this.params = params\n    this.size = size\n  }\n}\n\nexport type AbiDecodingOffsetOutOfBoundsErrorType =\n  AbiDecodingOffsetOutOfBoundsError & {\n    name: 'AbiDecodingOffsetOutOfBoundsError'\n  }\nexport class AbiDecodingOffsetOutOfBoundsError extends BaseError {\n  override name = 'AbiDecodingOffsetOutOfBoundsError'\n  constructor({ offset, position }: { offset: number; position: number }) {\n    super(\n      `Offset at \"${offset}\" is out-of-bounds (current position: \"${position}\").`,\n    )\n  }\n}\n\nexport type AbiDecodingZeroDataErrorType = AbiDecodingZeroDataError & {\n  name: 'AbiDecodingZeroDataError'\n}\nexport class AbiDecodingZeroDataError extends BaseError {\n  override name = 'AbiDecodingZeroDataError'\n  constructor() {\n    super('Cannot decode zero data (\"0x\") with ABI parameters.')\n  }\n}\n\nexport type AbiEncodingArrayLengthMismatchErrorType =\n  AbiEncodingArrayLengthMismatchError & {\n    name: 'AbiEncodingArrayLengthMismatchError'\n  }\nexport class AbiEncodingArrayLengthMismatchError extends BaseError {\n  override name = 'AbiEncodingArrayLengthMismatchError'\n  constructor({\n    expectedLength,\n    givenLength,\n    type,\n  }: { expectedLength: number; givenLength: number; type: string }) {\n    super(\n      [\n        `ABI encoding array length mismatch for type ${type}.`,\n        `Expected length: ${expectedLength}`,\n        `Given length: ${givenLength}`,\n      ].join('\\n'),\n    )\n  }\n}\n\nexport type AbiEncodingBytesSizeMismatchErrorType =\n  AbiEncodingBytesSizeMismatchError & {\n    name: 'AbiEncodingBytesSizeMismatchError'\n  }\nexport class AbiEncodingBytesSizeMismatchError extends BaseError {\n  override name = 'AbiEncodingBytesSizeMismatchError'\n  constructor({ expectedSize, value }: { expectedSize: number; value: Hex }) {\n    super(\n      `Size of bytes \"${value}\" (bytes${size(\n        value,\n      )}) does not match expected size (bytes${expectedSize}).`,\n    )\n  }\n}\n\nexport type AbiEncodingLengthMismatchErrorType =\n  AbiEncodingLengthMismatchError & {\n    name: 'AbiEncodingLengthMismatchError'\n  }\nexport class AbiEncodingLengthMismatchError extends BaseError {\n  override name = 'AbiEncodingLengthMismatchError'\n  constructor({\n    expectedLength,\n    givenLength,\n  }: { expectedLength: number; givenLength: number }) {\n    super(\n      [\n        'ABI encoding params/values length mismatch.',\n        `Expected length (params): ${expectedLength}`,\n        `Given length (values): ${givenLength}`,\n      ].join('\\n'),\n    )\n  }\n}\n\nexport type AbiErrorInputsNotFoundErrorType = AbiErrorInputsNotFoundError & {\n  name: 'AbiErrorInputsNotFoundError'\n}\nexport class AbiErrorInputsNotFoundError extends BaseError {\n  override name = 'AbiErrorInputsNotFoundError'\n  constructor(errorName: string, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Arguments (\\`args\\`) were provided to \"${errorName}\", but \"${errorName}\" on the ABI does not contain any parameters (\\`inputs\\`).`,\n        'Cannot encode error result without knowing what the parameter types are.',\n        'Make sure you are using the correct ABI and that the inputs exist on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n      },\n    )\n  }\n}\n\nexport type AbiErrorNotFoundErrorType = AbiErrorNotFoundError & {\n  name: 'AbiErrorNotFoundError'\n}\nexport class AbiErrorNotFoundError extends BaseError {\n  override name = 'AbiErrorNotFoundError'\n  constructor(\n    errorName?: string | undefined,\n    { docsPath }: { docsPath?: string | undefined } = {},\n  ) {\n    super(\n      [\n        `Error ${errorName ? `\"${errorName}\" ` : ''}not found on ABI.`,\n        'Make sure you are using the correct ABI and that the error exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n      },\n    )\n  }\n}\n\nexport type AbiErrorSignatureNotFoundErrorType =\n  AbiErrorSignatureNotFoundError & {\n    name: 'AbiErrorSignatureNotFoundError'\n  }\nexport class AbiErrorSignatureNotFoundError extends BaseError {\n  override name = 'AbiErrorSignatureNotFoundError'\n\n  signature: Hex\n\n  constructor(signature: Hex, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Encoded error signature \"${signature}\" not found on ABI.`,\n        'Make sure you are using the correct ABI and that the error exists on it.',\n        `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature}.`,\n      ].join('\\n'),\n      {\n        docsPath,\n      },\n    )\n    this.signature = signature\n  }\n}\n\nexport type AbiEventSignatureEmptyTopicsErrorType =\n  AbiEventSignatureEmptyTopicsError & {\n    name: 'AbiEventSignatureEmptyTopicsError'\n  }\nexport class AbiEventSignatureEmptyTopicsError extends BaseError {\n  override name = 'AbiEventSignatureEmptyTopicsError'\n  constructor({ docsPath }: { docsPath: string }) {\n    super('Cannot extract event signature from empty topics.', {\n      docsPath,\n    })\n  }\n}\n\nexport type AbiEventSignatureNotFoundErrorType =\n  AbiEventSignatureNotFoundError & {\n    name: 'AbiEventSignatureNotFoundError'\n  }\nexport class AbiEventSignatureNotFoundError extends BaseError {\n  override name = 'AbiEventSignatureNotFoundError'\n  constructor(signature: Hex, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Encoded event signature \"${signature}\" not found on ABI.`,\n        'Make sure you are using the correct ABI and that the event exists on it.',\n        `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`,\n      ].join('\\n'),\n      {\n        docsPath,\n      },\n    )\n  }\n}\n\nexport type AbiEventNotFoundErrorType = AbiEventNotFoundError & {\n  name: 'AbiEventNotFoundError'\n}\nexport class AbiEventNotFoundError extends BaseError {\n  override name = 'AbiEventNotFoundError'\n  constructor(\n    eventName?: string | undefined,\n    { docsPath }: { docsPath?: string | undefined } = {},\n  ) {\n    super(\n      [\n        `Event ${eventName ? `\"${eventName}\" ` : ''}not found on ABI.`,\n        'Make sure you are using the correct ABI and that the event exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n      },\n    )\n  }\n}\n\nexport type AbiFunctionNotFoundErrorType = AbiFunctionNotFoundError & {\n  name: 'AbiFunctionNotFoundError'\n}\nexport class AbiFunctionNotFoundError extends BaseError {\n  override name = 'AbiFunctionNotFoundError'\n  constructor(\n    functionName?: string | undefined,\n    { docsPath }: { docsPath?: string | undefined } = {},\n  ) {\n    super(\n      [\n        `Function ${functionName ? `\"${functionName}\" ` : ''}not found on ABI.`,\n        'Make sure you are using the correct ABI and that the function exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n      },\n    )\n  }\n}\n\nexport type AbiFunctionOutputsNotFoundErrorType =\n  AbiFunctionOutputsNotFoundError & {\n    name: 'AbiFunctionOutputsNotFoundError'\n  }\nexport class AbiFunctionOutputsNotFoundError extends BaseError {\n  override name = 'AbiFunctionOutputsNotFoundError'\n  constructor(functionName: string, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Function \"${functionName}\" does not contain any \\`outputs\\` on ABI.`,\n        'Cannot decode function result without knowing what the parameter types are.',\n        'Make sure you are using the correct ABI and that the function exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n      },\n    )\n  }\n}\n\nexport type AbiFunctionSignatureNotFoundErrorType =\n  AbiFunctionSignatureNotFoundError & {\n    name: 'AbiFunctionSignatureNotFoundError'\n  }\nexport class AbiFunctionSignatureNotFoundError extends BaseError {\n  override name = 'AbiFunctionSignatureNotFoundError'\n  constructor(signature: Hex, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Encoded function signature \"${signature}\" not found on ABI.`,\n        'Make sure you are using the correct ABI and that the function exists on it.',\n        `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`,\n      ].join('\\n'),\n      {\n        docsPath,\n      },\n    )\n  }\n}\n\nexport type AbiItemAmbiguityErrorType = AbiItemAmbiguityError & {\n  name: 'AbiItemAmbiguityError'\n}\nexport class AbiItemAmbiguityError extends BaseError {\n  override name = 'AbiItemAmbiguityError'\n  constructor(\n    x: { abiItem: Abi[number]; type: string },\n    y: { abiItem: Abi[number]; type: string },\n  ) {\n    super('Found ambiguous types in overloaded ABI items.', {\n      metaMessages: [\n        `\\`${x.type}\\` in \\`${formatAbiItem(x.abiItem)}\\`, and`,\n        `\\`${y.type}\\` in \\`${formatAbiItem(y.abiItem)}\\``,\n        '',\n        'These types encode differently and cannot be distinguished at runtime.',\n        'Remove one of the ambiguous items in the ABI.',\n      ],\n    })\n  }\n}\n\nexport type BytesSizeMismatchErrorType = BytesSizeMismatchError & {\n  name: 'BytesSizeMismatchError'\n}\nexport class BytesSizeMismatchError extends BaseError {\n  override name = 'BytesSizeMismatchError'\n  constructor({\n    expectedSize,\n    givenSize,\n  }: { expectedSize: number; givenSize: number }) {\n    super(`Expected bytes${expectedSize}, got bytes${givenSize}.`)\n  }\n}\n\nexport type DecodeLogDataMismatchErrorType = DecodeLogDataMismatch & {\n  name: 'DecodeLogDataMismatch'\n}\nexport class DecodeLogDataMismatch extends BaseError {\n  override name = 'DecodeLogDataMismatch'\n\n  abiItem: AbiEvent\n  data: Hex\n  params: readonly AbiParameter[]\n  size: number\n\n  constructor({\n    abiItem,\n    data,\n    params,\n    size,\n  }: {\n    abiItem: AbiEvent\n    data: Hex\n    params: readonly AbiParameter[]\n    size: number\n  }) {\n    super(\n      [\n        `Data size of ${size} bytes is too small for non-indexed event parameters.`,\n      ].join('\\n'),\n      {\n        metaMessages: [\n          `Params: (${formatAbiParams(params, { includeName: true })})`,\n          `Data:   ${data} (${size} bytes)`,\n        ],\n      },\n    )\n\n    this.abiItem = abiItem\n    this.data = data\n    this.params = params\n    this.size = size\n  }\n}\n\nexport type DecodeLogTopicsMismatchErrorType = DecodeLogTopicsMismatch & {\n  name: 'DecodeLogTopicsMismatch'\n}\nexport class DecodeLogTopicsMismatch extends BaseError {\n  override name = 'DecodeLogTopicsMismatch'\n\n  abiItem: AbiEvent\n\n  constructor({\n    abiItem,\n    param,\n  }: {\n    abiItem: AbiEvent\n    param: AbiParameter & { indexed: boolean }\n  }) {\n    super(\n      [\n        `Expected a topic for indexed event parameter${\n          param.name ? ` \"${param.name}\"` : ''\n        } on event \"${formatAbiItem(abiItem, { includeName: true })}\".`,\n      ].join('\\n'),\n    )\n\n    this.abiItem = abiItem\n  }\n}\n\nexport type InvalidAbiEncodingTypeErrorType = InvalidAbiEncodingTypeError & {\n  name: 'InvalidAbiEncodingTypeError'\n}\nexport class InvalidAbiEncodingTypeError extends BaseError {\n  override name = 'InvalidAbiEncodingType'\n  constructor(type: string, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Type \"${type}\" is not a valid encoding type.`,\n        'Please provide a valid ABI type.',\n      ].join('\\n'),\n      { docsPath },\n    )\n  }\n}\n\nexport type InvalidAbiDecodingTypeErrorType = InvalidAbiDecodingTypeError & {\n  name: 'InvalidAbiDecodingTypeError'\n}\nexport class InvalidAbiDecodingTypeError extends BaseError {\n  override name = 'InvalidAbiDecodingType'\n  constructor(type: string, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Type \"${type}\" is not a valid decoding type.`,\n        'Please provide a valid ABI type.',\n      ].join('\\n'),\n      { docsPath },\n    )\n  }\n}\n\nexport type InvalidArrayErrorType = InvalidArrayError & {\n  name: 'InvalidArrayError'\n}\nexport class InvalidArrayError extends BaseError {\n  override name = 'InvalidArrayError'\n  constructor(value: unknown) {\n    super([`Value \"${value}\" is not a valid array.`].join('\\n'))\n  }\n}\n\nexport type InvalidDefinitionTypeErrorType = InvalidDefinitionTypeError & {\n  name: 'InvalidDefinitionTypeError'\n}\nexport class InvalidDefinitionTypeError extends BaseError {\n  override name = 'InvalidDefinitionTypeError'\n  constructor(type: string) {\n    super(\n      [\n        `\"${type}\" is not a valid definition type.`,\n        'Valid types: \"function\", \"event\", \"error\"',\n      ].join('\\n'),\n    )\n  }\n}\n\nexport type UnsupportedPackedAbiTypeErrorType = UnsupportedPackedAbiType & {\n  name: 'UnsupportedPackedAbiType'\n}\nexport class UnsupportedPackedAbiType extends BaseError {\n  override name = 'UnsupportedPackedAbiType'\n  constructor(type: unknown) {\n    super(`Type \"${type}\" is not supported for packed encoding.`)\n  }\n}\n","/**\n * Map with a LRU (Least recently used) policy.\n *\n * @link https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU\n */\nexport class LruMap<value = unknown> extends Map<string, value> {\n  maxSize: number\n\n  constructor(size: number) {\n    super()\n    this.maxSize = size\n  }\n\n  override set(key: string, value: value) {\n    super.set(key, value)\n    if (this.maxSize && this.size > this.maxSize)\n      this.delete(this.keys().next().value)\n    return this\n  }\n}\n","import type { Address } from 'abitype'\n\nimport { InvalidAddressError } from '../../errors/address.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport {\n  type StringToBytesErrorType,\n  stringToBytes,\n} from '../encoding/toBytes.js'\nimport { type Keccak256ErrorType, keccak256 } from '../hash/keccak256.js'\nimport { LruMap } from '../lru.js'\nimport { type IsAddressErrorType, isAddress } from './isAddress.js'\n\nexport const checksumAddressCache = /*#__PURE__*/ new LruMap<Address>(8192)\n\nexport type ChecksumAddressErrorType =\n  | Keccak256ErrorType\n  | StringToBytesErrorType\n  | ErrorType\n\nexport function checksumAddress(\n  address_: Address,\n  /**\n   * Warning: EIP-1191 checksum addresses are generally not backwards compatible with the\n   * wider Ethereum ecosystem, meaning it will break when validated against an application/tool\n   * that relies on EIP-55 checksum encoding (checksum without chainId).\n   *\n   * It is highly recommended to not use this feature unless you\n   * know what you are doing.\n   *\n   * See more: https://github.com/ethereum/EIPs/issues/1121\n   */\n  chainId?: number | undefined,\n): Address {\n  if (checksumAddressCache.has(`${address_}.${chainId}`))\n    return checksumAddressCache.get(`${address_}.${chainId}`)!\n\n  const hexAddress = chainId\n    ? `${chainId}${address_.toLowerCase()}`\n    : address_.substring(2).toLowerCase()\n  const hash = keccak256(stringToBytes(hexAddress), 'bytes')\n\n  const address = (\n    chainId ? hexAddress.substring(`${chainId}0x`.length) : hexAddress\n  ).split('')\n  for (let i = 0; i < 40; i += 2) {\n    if (hash[i >> 1] >> 4 >= 8 && address[i]) {\n      address[i] = address[i].toUpperCase()\n    }\n    if ((hash[i >> 1] & 0x0f) >= 8 && address[i + 1]) {\n      address[i + 1] = address[i + 1].toUpperCase()\n    }\n  }\n\n  const result = `0x${address.join('')}` as const\n  checksumAddressCache.set(`${address_}.${chainId}`, result)\n  return result\n}\n\nexport type GetAddressErrorType =\n  | ChecksumAddressErrorType\n  | IsAddressErrorType\n  | ErrorType\n\nexport function getAddress(\n  address: string,\n  /**\n   * Warning: EIP-1191 checksum addresses are generally not backwards compatible with the\n   * wider Ethereum ecosystem, meaning it will break when validated against an application/tool\n   * that relies on EIP-55 checksum encoding (checksum without chainId).\n   *\n   * It is highly recommended to not use this feature unless you\n   * know what you are doing.\n   *\n   * See more: https://github.com/ethereum/EIPs/issues/1121\n   */\n  chainId?: number,\n): Address {\n  if (!isAddress(address, { strict: false }))\n    throw new InvalidAddressError({ address })\n  return checksumAddress(address, chainId)\n}\n","import { BaseError } from './base.js'\n\nexport type NegativeOffsetErrorType = NegativeOffsetError & {\n  name: 'NegativeOffsetError'\n}\nexport class NegativeOffsetError extends BaseError {\n  override name = 'NegativeOffsetError'\n  constructor({ offset }: { offset: number }) {\n    super(`Offset \\`${offset}\\` cannot be negative.`)\n  }\n}\n\nexport type PositionOutOfBoundsErrorType = PositionOutOfBoundsError & {\n  name: 'PositionOutOfBoundsError'\n}\nexport class PositionOutOfBoundsError extends BaseError {\n  override name = 'PositionOutOfBoundsError'\n  constructor({ length, position }: { length: number; position: number }) {\n    super(\n      `Position \\`${position}\\` is out of bounds (\\`0 < position < ${length}\\`).`,\n    )\n  }\n}\n\nexport type RecursiveReadLimitExceededErrorType =\n  RecursiveReadLimitExceededError & {\n    name: 'RecursiveReadLimitExceededError'\n  }\nexport class RecursiveReadLimitExceededError extends BaseError {\n  override name = 'RecursiveReadLimitExceededError'\n  constructor({ count, limit }: { count: number; limit: number }) {\n    super(\n      `Recursive read limit of \\`${limit}\\` exceeded (recursive read count: \\`${count}\\`).`,\n    )\n  }\n}\n","import {\n  NegativeOffsetError,\n  PositionOutOfBoundsError,\n  RecursiveReadLimitExceededError,\n} from '../errors/cursor.js'\nimport type { ErrorType } from '../errors/utils.js'\nimport type { ByteArray } from '../types/misc.js'\n\nexport type Cursor = {\n  bytes: ByteArray\n  dataView: DataView\n  position: number\n  positionReadCount: Map<number, number>\n  recursiveReadCount: number\n  recursiveReadLimit: number\n  remaining: number\n  assertReadLimit(position?: number): void\n  assertPosition(position: number): void\n  decrementPosition(offset: number): void\n  getReadCount(position?: number): number\n  incrementPosition(offset: number): void\n  inspectByte(position?: number): ByteArray[number]\n  inspectBytes(length: number, position?: number): ByteArray\n  inspectUint8(position?: number): number\n  inspectUint16(position?: number): number\n  inspectUint24(position?: number): number\n  inspectUint32(position?: number): number\n  pushByte(byte: ByteArray[number]): void\n  pushBytes(bytes: ByteArray): void\n  pushUint8(value: number): void\n  pushUint16(value: number): void\n  pushUint24(value: number): void\n  pushUint32(value: number): void\n  readByte(): ByteArray[number]\n  readBytes(length: number, size?: number): ByteArray\n  readUint8(): number\n  readUint16(): number\n  readUint24(): number\n  readUint32(): number\n  setPosition(position: number): () => void\n  _touch(): void\n}\n\nexport type CreateCursorErrorType = ErrorType\n\nexport type CursorErrorType =\n  | CursorAssertPositionErrorType\n  | CursorDecrementPositionErrorType\n  | CursorIncrementPositionErrorType\n  | ErrorType\n\nexport type CursorAssertPositionErrorType = PositionOutOfBoundsError | ErrorType\n\nexport type CursorDecrementPositionErrorType = NegativeOffsetError | ErrorType\n\nexport type CursorIncrementPositionErrorType = NegativeOffsetError | ErrorType\n\nconst staticCursor: Cursor = {\n  bytes: new Uint8Array(),\n  dataView: new DataView(new ArrayBuffer(0)),\n  position: 0,\n  positionReadCount: new Map(),\n  recursiveReadCount: 0,\n  recursiveReadLimit: Number.POSITIVE_INFINITY,\n  assertReadLimit() {\n    if (this.recursiveReadCount >= this.recursiveReadLimit)\n      throw new RecursiveReadLimitExceededError({\n        count: this.recursiveReadCount + 1,\n        limit: this.recursiveReadLimit,\n      })\n  },\n  assertPosition(position) {\n    if (position < 0 || position > this.bytes.length - 1)\n      throw new PositionOutOfBoundsError({\n        length: this.bytes.length,\n        position,\n      })\n  },\n  decrementPosition(offset) {\n    if (offset < 0) throw new NegativeOffsetError({ offset })\n    const position = this.position - offset\n    this.assertPosition(position)\n    this.position = position\n  },\n  getReadCount(position) {\n    return this.positionReadCount.get(position || this.position) || 0\n  },\n  incrementPosition(offset) {\n    if (offset < 0) throw new NegativeOffsetError({ offset })\n    const position = this.position + offset\n    this.assertPosition(position)\n    this.position = position\n  },\n  inspectByte(position_) {\n    const position = position_ ?? this.position\n    this.assertPosition(position)\n    return this.bytes[position]\n  },\n  inspectBytes(length, position_) {\n    const position = position_ ?? this.position\n    this.assertPosition(position + length - 1)\n    return this.bytes.subarray(position, position + length)\n  },\n  inspectUint8(position_) {\n    const position = position_ ?? this.position\n    this.assertPosition(position)\n    return this.bytes[position]\n  },\n  inspectUint16(position_) {\n    const position = position_ ?? this.position\n    this.assertPosition(position + 1)\n    return this.dataView.getUint16(position)\n  },\n  inspectUint24(position_) {\n    const position = position_ ?? this.position\n    this.assertPosition(position + 2)\n    return (\n      (this.dataView.getUint16(position) << 8) +\n      this.dataView.getUint8(position + 2)\n    )\n  },\n  inspectUint32(position_) {\n    const position = position_ ?? this.position\n    this.assertPosition(position + 3)\n    return this.dataView.getUint32(position)\n  },\n  pushByte(byte: ByteArray[number]) {\n    this.assertPosition(this.position)\n    this.bytes[this.position] = byte\n    this.position++\n  },\n  pushBytes(bytes: ByteArray) {\n    this.assertPosition(this.position + bytes.length - 1)\n    this.bytes.set(bytes, this.position)\n    this.position += bytes.length\n  },\n  pushUint8(value: number) {\n    this.assertPosition(this.position)\n    this.bytes[this.position] = value\n    this.position++\n  },\n  pushUint16(value: number) {\n    this.assertPosition(this.position + 1)\n    this.dataView.setUint16(this.position, value)\n    this.position += 2\n  },\n  pushUint24(value: number) {\n    this.assertPosition(this.position + 2)\n    this.dataView.setUint16(this.position, value >> 8)\n    this.dataView.setUint8(this.position + 2, value & ~4294967040)\n    this.position += 3\n  },\n  pushUint32(value: number) {\n    this.assertPosition(this.position + 3)\n    this.dataView.setUint32(this.position, value)\n    this.position += 4\n  },\n  readByte() {\n    this.assertReadLimit()\n    this._touch()\n    const value = this.inspectByte()\n    this.position++\n    return value\n  },\n  readBytes(length, size) {\n    this.assertReadLimit()\n    this._touch()\n    const value = this.inspectBytes(length)\n    this.position += size ?? length\n    return value\n  },\n  readUint8() {\n    this.assertReadLimit()\n    this._touch()\n    const value = this.inspectUint8()\n    this.position += 1\n    return value\n  },\n  readUint16() {\n    this.assertReadLimit()\n    this._touch()\n    const value = this.inspectUint16()\n    this.position += 2\n    return value\n  },\n  readUint24() {\n    this.assertReadLimit()\n    this._touch()\n    const value = this.inspectUint24()\n    this.position += 3\n    return value\n  },\n  readUint32() {\n    this.assertReadLimit()\n    this._touch()\n    const value = this.inspectUint32()\n    this.position += 4\n    return value\n  },\n  get remaining() {\n    return this.bytes.length - this.position\n  },\n  setPosition(position) {\n    const oldPosition = this.position\n    this.assertPosition(position)\n    this.position = position\n    return () => (this.position = oldPosition)\n  },\n  _touch() {\n    if (this.recursiveReadLimit === Number.POSITIVE_INFINITY) return\n    const count = this.getReadCount()\n    this.positionReadCount.set(this.position, count + 1)\n    if (count > 0) this.recursiveReadCount++\n  },\n}\n\ntype CursorConfig = { recursiveReadLimit?: number | undefined }\n\nexport function createCursor(\n  bytes: ByteArray,\n  { recursiveReadLimit = 8_192 }: CursorConfig = {},\n): Cursor {\n  const cursor: Cursor = Object.create(staticCursor)\n  cursor.bytes = bytes\n  cursor.dataView = new DataView(\n    bytes.buffer,\n    bytes.byteOffset,\n    bytes.byteLength,\n  )\n  cursor.positionReadCount = new Map()\n  cursor.recursiveReadLimit = recursiveReadLimit\n  return cursor\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\n\ntype TrimOptions = {\n  dir?: 'left' | 'right' | undefined\n}\nexport type TrimReturnType<TValue extends ByteArray | Hex> = TValue extends Hex\n  ? Hex\n  : ByteArray\n\nexport type TrimErrorType = ErrorType\n\nexport function trim<TValue extends ByteArray | Hex>(\n  hexOrBytes: TValue,\n  { dir = 'left' }: TrimOptions = {},\n): TrimReturnType<TValue> {\n  let data: any =\n    typeof hexOrBytes === 'string' ? hexOrBytes.replace('0x', '') : hexOrBytes\n\n  let sliceLength = 0\n  for (let i = 0; i < data.length - 1; i++) {\n    if (data[dir === 'left' ? i : data.length - i - 1].toString() === '0')\n      sliceLength++\n    else break\n  }\n  data =\n    dir === 'left'\n      ? data.slice(sliceLength)\n      : data.slice(0, data.length - sliceLength)\n\n  if (typeof hexOrBytes === 'string') {\n    if (data.length === 1 && dir === 'right') data = `${data}0`\n    return `0x${\n      data.length % 2 === 1 ? `0${data}` : data\n    }` as TrimReturnType<TValue>\n  }\n  return data as TrimReturnType<TValue>\n}\n","import { InvalidBytesBooleanError } from '../../errors/encoding.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type TrimErrorType, trim } from '../data/trim.js'\n\nimport {\n  type AssertSizeErrorType,\n  type HexToBigIntErrorType,\n  type HexToNumberErrorType,\n  assertSize,\n  hexToBigInt,\n  hexToNumber,\n} from './fromHex.js'\nimport { type BytesToHexErrorType, bytesToHex } from './toHex.js'\n\nexport type FromBytesParameters<\n  TTo extends 'string' | 'hex' | 'bigint' | 'number' | 'boolean',\n> =\n  | TTo\n  | {\n      /** Size of the bytes. */\n      size?: number | undefined\n      /** Type to convert to. */\n      to: TTo\n    }\n\nexport type FromBytesReturnType<TTo> = TTo extends 'string'\n  ? string\n  : TTo extends 'hex'\n    ? Hex\n    : TTo extends 'bigint'\n      ? bigint\n      : TTo extends 'number'\n        ? number\n        : TTo extends 'boolean'\n          ? boolean\n          : never\n\nexport type FromBytesErrorType =\n  | BytesToHexErrorType\n  | BytesToBigIntErrorType\n  | BytesToBoolErrorType\n  | BytesToNumberErrorType\n  | BytesToStringErrorType\n  | ErrorType\n\n/**\n * Decodes a byte array into a UTF-8 string, hex value, number, bigint or boolean.\n *\n * - Docs: https://viem.sh/docs/utilities/fromBytes\n * - Example: https://viem.sh/docs/utilities/fromBytes#usage\n *\n * @param bytes Byte array to decode.\n * @param toOrOpts Type to convert to or options.\n * @returns Decoded value.\n *\n * @example\n * import { fromBytes } from 'viem'\n * const data = fromBytes(new Uint8Array([1, 164]), 'number')\n * // 420\n *\n * @example\n * import { fromBytes } from 'viem'\n * const data = fromBytes(\n *   new Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]),\n *   'string'\n * )\n * // 'Hello world'\n */\nexport function fromBytes<\n  TTo extends 'string' | 'hex' | 'bigint' | 'number' | 'boolean',\n>(\n  bytes: ByteArray,\n  toOrOpts: FromBytesParameters<TTo>,\n): FromBytesReturnType<TTo> {\n  const opts = typeof toOrOpts === 'string' ? { to: toOrOpts } : toOrOpts\n  const to = opts.to\n\n  if (to === 'number')\n    return bytesToNumber(bytes, opts) as FromBytesReturnType<TTo>\n  if (to === 'bigint')\n    return bytesToBigInt(bytes, opts) as FromBytesReturnType<TTo>\n  if (to === 'boolean')\n    return bytesToBool(bytes, opts) as FromBytesReturnType<TTo>\n  if (to === 'string')\n    return bytesToString(bytes, opts) as FromBytesReturnType<TTo>\n  return bytesToHex(bytes, opts) as FromBytesReturnType<TTo>\n}\n\nexport type BytesToBigIntOpts = {\n  /** Whether or not the number of a signed representation. */\n  signed?: boolean | undefined\n  /** Size of the bytes. */\n  size?: number | undefined\n}\n\nexport type BytesToBigIntErrorType =\n  | BytesToHexErrorType\n  | HexToBigIntErrorType\n  | ErrorType\n\n/**\n * Decodes a byte array into a bigint.\n *\n * - Docs: https://viem.sh/docs/utilities/fromBytes#bytestobigint\n *\n * @param bytes Byte array to decode.\n * @param opts Options.\n * @returns BigInt value.\n *\n * @example\n * import { bytesToBigInt } from 'viem'\n * const data = bytesToBigInt(new Uint8Array([1, 164]))\n * // 420n\n */\nexport function bytesToBigInt(\n  bytes: ByteArray,\n  opts: BytesToBigIntOpts = {},\n): bigint {\n  if (typeof opts.size !== 'undefined') assertSize(bytes, { size: opts.size })\n  const hex = bytesToHex(bytes, opts)\n  return hexToBigInt(hex, opts)\n}\n\nexport type BytesToBoolOpts = {\n  /** Size of the bytes. */\n  size?: number | undefined\n}\n\nexport type BytesToBoolErrorType =\n  | AssertSizeErrorType\n  | TrimErrorType\n  | ErrorType\n\n/**\n * Decodes a byte array into a boolean.\n *\n * - Docs: https://viem.sh/docs/utilities/fromBytes#bytestobool\n *\n * @param bytes Byte array to decode.\n * @param opts Options.\n * @returns Boolean value.\n *\n * @example\n * import { bytesToBool } from 'viem'\n * const data = bytesToBool(new Uint8Array([1]))\n * // true\n */\nexport function bytesToBool(\n  bytes_: ByteArray,\n  opts: BytesToBoolOpts = {},\n): boolean {\n  let bytes = bytes_\n  if (typeof opts.size !== 'undefined') {\n    assertSize(bytes, { size: opts.size })\n    bytes = trim(bytes)\n  }\n  if (bytes.length > 1 || bytes[0] > 1)\n    throw new InvalidBytesBooleanError(bytes)\n  return Boolean(bytes[0])\n}\n\nexport type BytesToNumberOpts = BytesToBigIntOpts\n\nexport type BytesToNumberErrorType =\n  | BytesToHexErrorType\n  | HexToNumberErrorType\n  | ErrorType\n\n/**\n * Decodes a byte array into a number.\n *\n * - Docs: https://viem.sh/docs/utilities/fromBytes#bytestonumber\n *\n * @param bytes Byte array to decode.\n * @param opts Options.\n * @returns Number value.\n *\n * @example\n * import { bytesToNumber } from 'viem'\n * const data = bytesToNumber(new Uint8Array([1, 164]))\n * // 420\n */\nexport function bytesToNumber(\n  bytes: ByteArray,\n  opts: BytesToNumberOpts = {},\n): number {\n  if (typeof opts.size !== 'undefined') assertSize(bytes, { size: opts.size })\n  const hex = bytesToHex(bytes, opts)\n  return hexToNumber(hex, opts)\n}\n\nexport type BytesToStringOpts = {\n  /** Size of the bytes. */\n  size?: number | undefined\n}\n\nexport type BytesToStringErrorType =\n  | AssertSizeErrorType\n  | TrimErrorType\n  | ErrorType\n\n/**\n * Decodes a byte array into a UTF-8 string.\n *\n * - Docs: https://viem.sh/docs/utilities/fromBytes#bytestostring\n *\n * @param bytes Byte array to decode.\n * @param opts Options.\n * @returns String value.\n *\n * @example\n * import { bytesToString } from 'viem'\n * const data = bytesToString(new Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // 'Hello world'\n */\nexport function bytesToString(\n  bytes_: ByteArray,\n  opts: BytesToStringOpts = {},\n): string {\n  let bytes = bytes_\n  if (typeof opts.size !== 'undefined') {\n    assertSize(bytes, { size: opts.size })\n    bytes = trim(bytes, { dir: 'right' })\n  }\n  return new TextDecoder().decode(bytes)\n}\n","import type {\n  AbiParameter,\n  AbiParameterToPrimitiveType,\n  AbiParametersToPrimitiveTypes,\n} from 'abitype'\n\nimport {\n  AbiEncodingArrayLengthMismatchError,\n  type AbiEncodingArrayLengthMismatchErrorType,\n  AbiEncodingBytesSizeMismatchError,\n  type AbiEncodingBytesSizeMismatchErrorType,\n  AbiEncodingLengthMismatchError,\n  type AbiEncodingLengthMismatchErrorType,\n  InvalidAbiEncodingTypeError,\n  type InvalidAbiEncodingTypeErrorType,\n  InvalidArrayError,\n  type InvalidArrayErrorType,\n} from '../../errors/abi.js'\nimport {\n  InvalidAddressError,\n  type InvalidAddressErrorType,\n} from '../../errors/address.js'\nimport { BaseError } from '../../errors/base.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\nimport { type IsAddressErrorType, isAddress } from '../address/isAddress.js'\nimport { type ConcatErrorType, concat } from '../data/concat.js'\nimport { type PadHexErrorType, padHex } from '../data/pad.js'\nimport { type SizeErrorType, size } from '../data/size.js'\nimport { type SliceErrorType, slice } from '../data/slice.js'\nimport {\n  type BoolToHexErrorType,\n  type NumberToHexErrorType,\n  type StringToHexErrorType,\n  boolToHex,\n  numberToHex,\n  stringToHex,\n} from '../encoding/toHex.js'\n\nexport type EncodeAbiParametersReturnType = Hex\n\nexport type EncodeAbiParametersErrorType =\n  | AbiEncodingLengthMismatchErrorType\n  | PrepareParamsErrorType\n  | EncodeParamsErrorType\n  | ErrorType\n\n/**\n * @description Encodes a list of primitive values into an ABI-encoded hex value.\n *\n * - Docs: https://viem.sh/docs/abi/encodeAbiParameters#encodeabiparameters\n *\n *   Generates ABI encoded data using the [ABI specification](https://docs.soliditylang.org/en/latest/abi-spec), given a set of ABI parameters (inputs/outputs) and their corresponding values.\n *\n * @param params - a set of ABI Parameters (params), that can be in the shape of the inputs or outputs attribute of an ABI Item.\n * @param values - a set of values (values) that correspond to the given params.\n * @example\n * ```typescript\n * import { encodeAbiParameters } from 'viem'\n *\n * const encodedData = encodeAbiParameters(\n *   [\n *     { name: 'x', type: 'string' },\n *     { name: 'y', type: 'uint' },\n *     { name: 'z', type: 'bool' }\n *   ],\n *   ['wagmi', 420n, true]\n * )\n * ```\n *\n * You can also pass in Human Readable parameters with the parseAbiParameters utility.\n *\n * @example\n * ```typescript\n * import { encodeAbiParameters, parseAbiParameters } from 'viem'\n *\n * const encodedData = encodeAbiParameters(\n *   parseAbiParameters('string x, uint y, bool z'),\n *   ['wagmi', 420n, true]\n * )\n * ```\n */\nexport function encodeAbiParameters<\n  const TParams extends readonly AbiParameter[] | readonly unknown[],\n>(\n  params: TParams,\n  values: TParams extends readonly AbiParameter[]\n    ? AbiParametersToPrimitiveTypes<TParams>\n    : never,\n): EncodeAbiParametersReturnType {\n  if (params.length !== values.length)\n    throw new AbiEncodingLengthMismatchError({\n      expectedLength: params.length as number,\n      givenLength: values.length as any,\n    })\n  // Prepare the parameters to determine dynamic types to encode.\n  const preparedParams = prepareParams({\n    params: params as readonly AbiParameter[],\n    values: values as any,\n  })\n  const data = encodeParams(preparedParams)\n  if (data.length === 0) return '0x'\n  return data\n}\n\n/////////////////////////////////////////////////////////////////\n\ntype PreparedParam = { dynamic: boolean; encoded: Hex }\n\ntype TupleAbiParameter = AbiParameter & { components: readonly AbiParameter[] }\ntype Tuple = AbiParameterToPrimitiveType<TupleAbiParameter>\n\nexport type PrepareParamsErrorType = ErrorType\n\nfunction prepareParams<const TParams extends readonly AbiParameter[]>({\n  params,\n  values,\n}: {\n  params: TParams\n  values: AbiParametersToPrimitiveTypes<TParams>\n}) {\n  const preparedParams: PreparedParam[] = []\n  for (let i = 0; i < params.length; i++) {\n    preparedParams.push(prepareParam({ param: params[i], value: values[i] }))\n  }\n  return preparedParams\n}\n\nexport type PrepareParamErrorType =\n  | GetArrayComponentsErrorType\n  | InvalidAbiEncodingTypeErrorType\n  | ErrorType\n\nfunction prepareParam<const TParam extends AbiParameter>({\n  param,\n  value,\n}: {\n  param: TParam\n  value: AbiParameterToPrimitiveType<TParam>\n}): PreparedParam {\n  const arrayComponents = getArrayComponents(param.type)\n  if (arrayComponents) {\n    const [length, type] = arrayComponents\n    return encodeArray(value, { length, param: { ...param, type } })\n  }\n  if (param.type === 'tuple') {\n    return encodeTuple(value as unknown as Tuple, {\n      param: param as TupleAbiParameter,\n    })\n  }\n  if (param.type === 'address') {\n    return encodeAddress(value as unknown as Hex)\n  }\n  if (param.type === 'bool') {\n    return encodeBool(value as unknown as boolean)\n  }\n  if (param.type.startsWith('uint') || param.type.startsWith('int')) {\n    const signed = param.type.startsWith('int')\n    return encodeNumber(value as unknown as number, { signed })\n  }\n  if (param.type.startsWith('bytes')) {\n    return encodeBytes(value as unknown as Hex, { param })\n  }\n  if (param.type === 'string') {\n    return encodeString(value as unknown as string)\n  }\n  throw new InvalidAbiEncodingTypeError(param.type, {\n    docsPath: '/docs/contract/encodeAbiParameters',\n  })\n}\n\n/////////////////////////////////////////////////////////////////\n\nexport type EncodeParamsErrorType =\n  | NumberToHexErrorType\n  | SizeErrorType\n  | ErrorType\n\nfunction encodeParams(preparedParams: PreparedParam[]): Hex {\n  // 1. Compute the size of the static part of the parameters.\n  let staticSize = 0\n  for (let i = 0; i < preparedParams.length; i++) {\n    const { dynamic, encoded } = preparedParams[i]\n    if (dynamic) staticSize += 32\n    else staticSize += size(encoded)\n  }\n\n  // 2. Split the parameters into static and dynamic parts.\n  const staticParams: Hex[] = []\n  const dynamicParams: Hex[] = []\n  let dynamicSize = 0\n  for (let i = 0; i < preparedParams.length; i++) {\n    const { dynamic, encoded } = preparedParams[i]\n    if (dynamic) {\n      staticParams.push(numberToHex(staticSize + dynamicSize, { size: 32 }))\n      dynamicParams.push(encoded)\n      dynamicSize += size(encoded)\n    } else {\n      staticParams.push(encoded)\n    }\n  }\n\n  // 3. Concatenate static and dynamic parts.\n  return concat([...staticParams, ...dynamicParams])\n}\n\n/////////////////////////////////////////////////////////////////\n\nexport type EncodeAddressErrorType =\n  | InvalidAddressErrorType\n  | IsAddressErrorType\n  | ErrorType\n\nfunction encodeAddress(value: Hex): PreparedParam {\n  if (!isAddress(value)) throw new InvalidAddressError({ address: value })\n  return { dynamic: false, encoded: padHex(value.toLowerCase() as Hex) }\n}\n\nexport type EncodeArrayErrorType =\n  | AbiEncodingArrayLengthMismatchErrorType\n  | ConcatErrorType\n  | EncodeParamsErrorType\n  | InvalidArrayErrorType\n  | NumberToHexErrorType\n  | PrepareParamErrorType\n  | ErrorType\n\nfunction encodeArray<const TParam extends AbiParameter>(\n  value: AbiParameterToPrimitiveType<TParam>,\n  {\n    length,\n    param,\n  }: {\n    length: number | null\n    param: TParam\n  },\n): PreparedParam {\n  const dynamic = length === null\n\n  if (!Array.isArray(value)) throw new InvalidArrayError(value)\n  if (!dynamic && value.length !== length)\n    throw new AbiEncodingArrayLengthMismatchError({\n      expectedLength: length!,\n      givenLength: value.length,\n      type: `${param.type}[${length}]`,\n    })\n\n  let dynamicChild = false\n  const preparedParams: PreparedParam[] = []\n  for (let i = 0; i < value.length; i++) {\n    const preparedParam = prepareParam({ param, value: value[i] })\n    if (preparedParam.dynamic) dynamicChild = true\n    preparedParams.push(preparedParam)\n  }\n\n  if (dynamic || dynamicChild) {\n    const data = encodeParams(preparedParams)\n    if (dynamic) {\n      const length = numberToHex(preparedParams.length, { size: 32 })\n      return {\n        dynamic: true,\n        encoded: preparedParams.length > 0 ? concat([length, data]) : length,\n      }\n    }\n    if (dynamicChild) return { dynamic: true, encoded: data }\n  }\n  return {\n    dynamic: false,\n    encoded: concat(preparedParams.map(({ encoded }) => encoded)),\n  }\n}\n\nexport type EncodeBytesErrorType =\n  | AbiEncodingBytesSizeMismatchErrorType\n  | ConcatErrorType\n  | PadHexErrorType\n  | NumberToHexErrorType\n  | SizeErrorType\n  | ErrorType\n\nfunction encodeBytes<const TParam extends AbiParameter>(\n  value: Hex,\n  { param }: { param: TParam },\n): PreparedParam {\n  const [, paramSize] = param.type.split('bytes')\n  const bytesSize = size(value)\n  if (!paramSize) {\n    let value_ = value\n    // If the size is not divisible by 32 bytes, pad the end\n    // with empty bytes to the ceiling 32 bytes.\n    if (bytesSize % 32 !== 0)\n      value_ = padHex(value_, {\n        dir: 'right',\n        size: Math.ceil((value.length - 2) / 2 / 32) * 32,\n      })\n    return {\n      dynamic: true,\n      encoded: concat([padHex(numberToHex(bytesSize, { size: 32 })), value_]),\n    }\n  }\n  if (bytesSize !== Number.parseInt(paramSize))\n    throw new AbiEncodingBytesSizeMismatchError({\n      expectedSize: Number.parseInt(paramSize),\n      value,\n    })\n  return { dynamic: false, encoded: padHex(value, { dir: 'right' }) }\n}\n\nexport type EncodeBoolErrorType =\n  | PadHexErrorType\n  | BoolToHexErrorType\n  | ErrorType\n\nfunction encodeBool(value: boolean): PreparedParam {\n  if (typeof value !== 'boolean')\n    throw new BaseError(\n      `Invalid boolean value: \"${value}\" (type: ${typeof value}). Expected: \\`true\\` or \\`false\\`.`,\n    )\n  return { dynamic: false, encoded: padHex(boolToHex(value)) }\n}\n\nexport type EncodeNumberErrorType = NumberToHexErrorType | ErrorType\n\nfunction encodeNumber(\n  value: number,\n  { signed }: { signed: boolean },\n): PreparedParam {\n  return {\n    dynamic: false,\n    encoded: numberToHex(value, {\n      size: 32,\n      signed,\n    }),\n  }\n}\n\nexport type EncodeStringErrorType =\n  | ConcatErrorType\n  | NumberToHexErrorType\n  | PadHexErrorType\n  | SizeErrorType\n  | SliceErrorType\n  | StringToHexErrorType\n  | ErrorType\n\nfunction encodeString(value: string): PreparedParam {\n  const hexValue = stringToHex(value)\n  const partsLength = Math.ceil(size(hexValue) / 32)\n  const parts: Hex[] = []\n  for (let i = 0; i < partsLength; i++) {\n    parts.push(\n      padHex(slice(hexValue, i * 32, (i + 1) * 32), {\n        dir: 'right',\n      }),\n    )\n  }\n  return {\n    dynamic: true,\n    encoded: concat([\n      padHex(numberToHex(size(hexValue), { size: 32 })),\n      ...parts,\n    ]),\n  }\n}\n\nexport type EncodeTupleErrorType =\n  | ConcatErrorType\n  | EncodeParamsErrorType\n  | PrepareParamErrorType\n  | ErrorType\n\nfunction encodeTuple<\n  const TParam extends AbiParameter & { components: readonly AbiParameter[] },\n>(\n  value: AbiParameterToPrimitiveType<TParam>,\n  { param }: { param: TParam },\n): PreparedParam {\n  let dynamic = false\n  const preparedParams: PreparedParam[] = []\n  for (let i = 0; i < param.components.length; i++) {\n    const param_ = param.components[i]\n    const index = Array.isArray(value) ? i : param_.name\n    const preparedParam = prepareParam({\n      param: param_,\n      value: (value as any)[index!] as readonly unknown[],\n    })\n    preparedParams.push(preparedParam)\n    if (preparedParam.dynamic) dynamic = true\n  }\n  return {\n    dynamic,\n    encoded: dynamic\n      ? encodeParams(preparedParams)\n      : concat(preparedParams.map(({ encoded }) => encoded)),\n  }\n}\n\nexport type GetArrayComponentsErrorType = ErrorType\n\nexport function getArrayComponents(\n  type: string,\n): [length: number | null, innerType: string] | undefined {\n  const matches = type.match(/^(.*)\\[(\\d+)?\\]$/)\n  return matches\n    ? // Return `null` if the array is dynamic.\n      [matches[2] ? Number(matches[2]) : null, matches[1]]\n    : undefined\n}\n","import type { AbiParameter, AbiParametersToPrimitiveTypes } from 'abitype'\n\nimport type { ByteArray, Hex } from '../../types/misc.js'\n\nimport {\n  AbiDecodingDataSizeTooSmallError,\n  AbiDecodingZeroDataError,\n  InvalidAbiDecodingTypeError,\n  type InvalidAbiDecodingTypeErrorType,\n} from '../../errors/abi.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport {\n  type ChecksumAddressErrorType,\n  checksumAddress,\n} from '../address/getAddress.js'\nimport { type Cursor, createCursor } from '../cursor.js'\nimport { type SizeErrorType, size } from '../data/size.js'\nimport { type SliceBytesErrorType, sliceBytes } from '../data/slice.js'\nimport { type TrimErrorType, trim } from '../data/trim.js'\nimport {\n  type BytesToBigIntErrorType,\n  type BytesToBoolErrorType,\n  type BytesToNumberErrorType,\n  type BytesToStringErrorType,\n  bytesToBigInt,\n  bytesToBool,\n  bytesToNumber,\n  bytesToString,\n} from '../encoding/fromBytes.js'\nimport { type HexToBytesErrorType, hexToBytes } from '../encoding/toBytes.js'\nimport { type BytesToHexErrorType, bytesToHex } from '../encoding/toHex.js'\nimport { getArrayComponents } from './encodeAbiParameters.js'\n\nexport type DecodeAbiParametersReturnType<\n  TParams extends readonly AbiParameter[] = readonly AbiParameter[],\n> = AbiParametersToPrimitiveTypes<\n  TParams extends readonly AbiParameter[] ? TParams : AbiParameter[]\n>\n\nexport type DecodeAbiParametersErrorType =\n  | HexToBytesErrorType\n  | BytesToHexErrorType\n  | DecodeParameterErrorType\n  | SizeErrorType\n  | ErrorType\n\nexport function decodeAbiParameters<\n  const TParams extends readonly AbiParameter[],\n>(\n  params: TParams,\n  data: ByteArray | Hex,\n): DecodeAbiParametersReturnType<TParams> {\n  const bytes = typeof data === 'string' ? hexToBytes(data) : data\n  const cursor = createCursor(bytes)\n\n  if (size(bytes) === 0 && params.length > 0)\n    throw new AbiDecodingZeroDataError()\n  if (size(data) && size(data) < 32)\n    throw new AbiDecodingDataSizeTooSmallError({\n      data: typeof data === 'string' ? data : bytesToHex(data),\n      params: params as readonly AbiParameter[],\n      size: size(data),\n    })\n\n  let consumed = 0\n  const values = []\n  for (let i = 0; i < params.length; ++i) {\n    const param = params[i]\n    cursor.setPosition(consumed)\n    const [data, consumed_] = decodeParameter(cursor, param, {\n      staticPosition: 0,\n    })\n    consumed += consumed_\n    values.push(data)\n  }\n  return values as DecodeAbiParametersReturnType<TParams>\n}\n\ntype DecodeParameterErrorType =\n  | DecodeArrayErrorType\n  | DecodeTupleErrorType\n  | DecodeAddressErrorType\n  | DecodeBoolErrorType\n  | DecodeBytesErrorType\n  | DecodeNumberErrorType\n  | DecodeStringErrorType\n  | InvalidAbiDecodingTypeErrorType\n\nfunction decodeParameter(\n  cursor: Cursor,\n  param: AbiParameter,\n  { staticPosition }: { staticPosition: number },\n) {\n  const arrayComponents = getArrayComponents(param.type)\n  if (arrayComponents) {\n    const [length, type] = arrayComponents\n    return decodeArray(cursor, { ...param, type }, { length, staticPosition })\n  }\n  if (param.type === 'tuple')\n    return decodeTuple(cursor, param as TupleAbiParameter, { staticPosition })\n\n  if (param.type === 'address') return decodeAddress(cursor)\n  if (param.type === 'bool') return decodeBool(cursor)\n  if (param.type.startsWith('bytes'))\n    return decodeBytes(cursor, param, { staticPosition })\n  if (param.type.startsWith('uint') || param.type.startsWith('int'))\n    return decodeNumber(cursor, param)\n  if (param.type === 'string') return decodeString(cursor, { staticPosition })\n  throw new InvalidAbiDecodingTypeError(param.type, {\n    docsPath: '/docs/contract/decodeAbiParameters',\n  })\n}\n\n////////////////////////////////////////////////////////////////////\n// Type Decoders\n\nconst sizeOfLength = 32\nconst sizeOfOffset = 32\n\ntype DecodeAddressErrorType =\n  | ChecksumAddressErrorType\n  | BytesToHexErrorType\n  | SliceBytesErrorType\n  | ErrorType\n\nfunction decodeAddress(cursor: Cursor) {\n  const value = cursor.readBytes(32)\n  return [checksumAddress(bytesToHex(sliceBytes(value, -20))), 32]\n}\n\ntype DecodeArrayErrorType = BytesToNumberErrorType | ErrorType\n\nfunction decodeArray(\n  cursor: Cursor,\n  param: AbiParameter,\n  { length, staticPosition }: { length: number | null; staticPosition: number },\n) {\n  // If the length of the array is not known in advance (dynamic array),\n  // this means we will need to wonder off to the pointer and decode.\n  if (!length) {\n    // Dealing with a dynamic type, so get the offset of the array data.\n    const offset = bytesToNumber(cursor.readBytes(sizeOfOffset))\n\n    // Start is the static position of current slot + offset.\n    const start = staticPosition + offset\n    const startOfData = start + sizeOfLength\n\n    // Get the length of the array from the offset.\n    cursor.setPosition(start)\n    const length = bytesToNumber(cursor.readBytes(sizeOfLength))\n\n    // Check if the array has any dynamic children.\n    const dynamicChild = hasDynamicChild(param)\n\n    let consumed = 0\n    const value: unknown[] = []\n    for (let i = 0; i < length; ++i) {\n      // If any of the children is dynamic, then all elements will be offset pointer, thus size of one slot (32 bytes).\n      // Otherwise, elements will be the size of their encoding (consumed bytes).\n      cursor.setPosition(startOfData + (dynamicChild ? i * 32 : consumed))\n      const [data, consumed_] = decodeParameter(cursor, param, {\n        staticPosition: startOfData,\n      })\n      consumed += consumed_\n      value.push(data)\n    }\n\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32)\n    return [value, 32]\n  }\n\n  // If the length of the array is known in advance,\n  // and the length of an element deeply nested in the array is not known,\n  // we need to decode the offset of the array data.\n  if (hasDynamicChild(param)) {\n    // Dealing with dynamic types, so get the offset of the array data.\n    const offset = bytesToNumber(cursor.readBytes(sizeOfOffset))\n\n    // Start is the static position of current slot + offset.\n    const start = staticPosition + offset\n\n    const value: unknown[] = []\n    for (let i = 0; i < length; ++i) {\n      // Move cursor along to the next slot (next offset pointer).\n      cursor.setPosition(start + i * 32)\n      const [data] = decodeParameter(cursor, param, {\n        staticPosition: start,\n      })\n      value.push(data)\n    }\n\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32)\n    return [value, 32]\n  }\n\n  // If the length of the array is known in advance and the array is deeply static,\n  // then we can just decode each element in sequence.\n  let consumed = 0\n  const value: unknown[] = []\n  for (let i = 0; i < length; ++i) {\n    const [data, consumed_] = decodeParameter(cursor, param, {\n      staticPosition: staticPosition + consumed,\n    })\n    consumed += consumed_\n    value.push(data)\n  }\n  return [value, consumed]\n}\n\ntype DecodeBoolErrorType = BytesToBoolErrorType | ErrorType\n\nfunction decodeBool(cursor: Cursor) {\n  return [bytesToBool(cursor.readBytes(32), { size: 32 }), 32]\n}\n\ntype DecodeBytesErrorType =\n  | BytesToNumberErrorType\n  | BytesToHexErrorType\n  | ErrorType\n\nfunction decodeBytes(\n  cursor: Cursor,\n  param: AbiParameter,\n  { staticPosition }: { staticPosition: number },\n) {\n  const [_, size] = param.type.split('bytes')\n  if (!size) {\n    // Dealing with dynamic types, so get the offset of the bytes data.\n    const offset = bytesToNumber(cursor.readBytes(32))\n\n    // Set position of the cursor to start of bytes data.\n    cursor.setPosition(staticPosition + offset)\n\n    const length = bytesToNumber(cursor.readBytes(32))\n\n    // If there is no length, we have zero data.\n    if (length === 0) {\n      // As we have gone wondering, restore to the original position + next slot.\n      cursor.setPosition(staticPosition + 32)\n      return ['0x', 32]\n    }\n\n    const data = cursor.readBytes(length)\n\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32)\n    return [bytesToHex(data), 32]\n  }\n\n  const value = bytesToHex(cursor.readBytes(Number.parseInt(size), 32))\n  return [value, 32]\n}\n\ntype DecodeNumberErrorType =\n  | BytesToNumberErrorType\n  | BytesToBigIntErrorType\n  | ErrorType\n\nfunction decodeNumber(cursor: Cursor, param: AbiParameter) {\n  const signed = param.type.startsWith('int')\n  const size = Number.parseInt(param.type.split('int')[1] || '256')\n  const value = cursor.readBytes(32)\n  return [\n    size > 48\n      ? bytesToBigInt(value, { signed })\n      : bytesToNumber(value, { signed }),\n    32,\n  ]\n}\n\ntype TupleAbiParameter = AbiParameter & { components: readonly AbiParameter[] }\n\ntype DecodeTupleErrorType = BytesToNumberErrorType | ErrorType\n\nfunction decodeTuple(\n  cursor: Cursor,\n  param: TupleAbiParameter,\n  { staticPosition }: { staticPosition: number },\n) {\n  // Tuples can have unnamed components (i.e. they are arrays), so we must\n  // determine whether the tuple is named or unnamed. In the case of a named\n  // tuple, the value will be an object where each property is the name of the\n  // component. In the case of an unnamed tuple, the value will be an array.\n  const hasUnnamedChild =\n    param.components.length === 0 || param.components.some(({ name }) => !name)\n\n  // Initialize the value to an object or an array, depending on whether the\n  // tuple is named or unnamed.\n  const value: any = hasUnnamedChild ? [] : {}\n  let consumed = 0\n\n  // If the tuple has a dynamic child, we must first decode the offset to the\n  // tuple data.\n  if (hasDynamicChild(param)) {\n    // Dealing with dynamic types, so get the offset of the tuple data.\n    const offset = bytesToNumber(cursor.readBytes(sizeOfOffset))\n\n    // Start is the static position of referencing slot + offset.\n    const start = staticPosition + offset\n\n    for (let i = 0; i < param.components.length; ++i) {\n      const component = param.components[i]\n      cursor.setPosition(start + consumed)\n      const [data, consumed_] = decodeParameter(cursor, component, {\n        staticPosition: start,\n      })\n      consumed += consumed_\n      value[hasUnnamedChild ? i : component?.name!] = data\n    }\n\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32)\n    return [value, 32]\n  }\n\n  // If the tuple has static children, we can just decode each component\n  // in sequence.\n  for (let i = 0; i < param.components.length; ++i) {\n    const component = param.components[i]\n    const [data, consumed_] = decodeParameter(cursor, component, {\n      staticPosition,\n    })\n    value[hasUnnamedChild ? i : component?.name!] = data\n    consumed += consumed_\n  }\n  return [value, consumed]\n}\n\ntype DecodeStringErrorType =\n  | BytesToNumberErrorType\n  | BytesToStringErrorType\n  | TrimErrorType\n  | ErrorType\n\nfunction decodeString(\n  cursor: Cursor,\n  { staticPosition }: { staticPosition: number },\n) {\n  // Get offset to start of string data.\n  const offset = bytesToNumber(cursor.readBytes(32))\n\n  // Start is the static position of current slot + offset.\n  const start = staticPosition + offset\n  cursor.setPosition(start)\n\n  const length = bytesToNumber(cursor.readBytes(32))\n\n  // If there is no length, we have zero data (empty string).\n  if (length === 0) {\n    cursor.setPosition(staticPosition + 32)\n    return ['', 32]\n  }\n\n  const data = cursor.readBytes(length, 32)\n  const value = bytesToString(trim(data))\n\n  // As we have gone wondering, restore to the original position + next slot.\n  cursor.setPosition(staticPosition + 32)\n\n  return [value, 32]\n}\n\nfunction hasDynamicChild(param: AbiParameter) {\n  const { type } = param\n  if (type === 'string') return true\n  if (type === 'bytes') return true\n  if (type.endsWith('[]')) return true\n\n  if (type === 'tuple') return (param as any).components?.some(hasDynamicChild)\n\n  const arrayComponents = getArrayComponents(param.type)\n  if (\n    arrayComponents &&\n    hasDynamicChild({ ...param, type: arrayComponents[1] } as AbiParameter)\n  )\n    return true\n\n  return false\n}\n","import type { EIP1193RequestFn, EIP1474Methods } from \"viem\";\nimport type { ThirdwebClient } from \"../client/client.js\";\n\nimport type { Chain } from \"../chains/types.js\";\nimport { getRpcUrlForChain } from \"../chains/utils.js\";\nimport { type RpcRequest, fetchRpc, fetchSingleRpc } from \"./fetch-rpc.js\";\n\nconst RPC_CLIENT_MAP = new WeakMap();\n\n/**\n * @internal\n */\nfunction getRpcClientMap(client: ThirdwebClient) {\n  if (RPC_CLIENT_MAP.has(client)) {\n    return RPC_CLIENT_MAP.get(client);\n  }\n  const rpcClientMap = new Map();\n  RPC_CLIENT_MAP.set(client, rpcClientMap);\n  return rpcClientMap;\n}\n\n/**\n * @internal\n */\nfunction rpcRequestKey(request: RpcRequest): string {\n  return `${request.method}:${JSON.stringify(request.params)}`;\n}\n\nconst DEFAULT_MAX_BATCH_SIZE = 100;\n// default to no timeout (next tick)\nconst DEFAULT_BATCH_TIMEOUT_MS = 0;\n\ntype RPCOptions = Readonly<{\n  client: ThirdwebClient;\n  chain: Chain;\n  config?: {\n    maxBatchSize?: number;\n    batchTimeoutMs?: number;\n    requestTimeoutMs?: number;\n  };\n}>;\n\n/**\n * Returns an RPC request that can be used to make JSON-RPC requests.\n * @param options - The RPC options.\n * @returns The RPC request function.\n * @rpc\n * @example\n * ```ts\n * import { createThirdwebClient } from \"thirdweb\";\n * import { getRpcClient } from \"thirdweb/rpc\";\n * import { ethereum } from \"thirdweb/chains\";\n * const client = createThirdwebClient({ clientId: \"...\" });\n * const rpcRequest = getRpcClient({ client, chain: ethereum, });\n * const blockNumber = await rpcRequest({\n *  method: \"eth_blockNumber\",\n * });\n * ```\n */\nexport function getRpcClient(\n  options: RPCOptions,\n): EIP1193RequestFn<EIP1474Methods> {\n  const rpcClientMap = getRpcClientMap(options.client);\n  const chainId = options.chain.id;\n\n  if (rpcClientMap.has(options.chain.rpc)) {\n    return rpcClientMap.get(\n      options.chain.rpc,\n    ) as EIP1193RequestFn<EIP1474Methods>;\n  }\n\n  const rpcClient: EIP1193RequestFn<EIP1474Methods> = (() => {\n    // we can do this upfront because it cannot change later\n    const rpcUrl = getRpcUrlForChain({\n      client: options.client,\n      chain: options.chain,\n    });\n\n    const batchSize =\n      // look at the direct options passed\n      options.config?.maxBatchSize ??\n      // look at the client options\n      options.client.config?.rpc?.maxBatchSize ??\n      // use defaults\n      DEFAULT_MAX_BATCH_SIZE;\n    const batchTimeoutMs =\n      // look at the direct options passed\n      options.config?.batchTimeoutMs ??\n      // look at the client options\n      options.client.config?.rpc?.batchTimeoutMs ??\n      DEFAULT_BATCH_TIMEOUT_MS;\n\n    // inflight requests\n    // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n    const inflightRequests = new Map<string, Promise<any>>();\n\n    let pendingBatch: Array<{\n      request: {\n        method: string;\n        params: unknown[];\n        id: number;\n        jsonrpc: \"2.0\";\n      };\n      // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n      resolve: (value: any) => void;\n      // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n      reject: (reason?: any) => void;\n      requestKey: string;\n    }> = [];\n    let pendingBatchTimeout: ReturnType<typeof setTimeout> | null = null;\n\n    /**\n     * Sends the pending batch of requests.\n     * @internal\n     */\n    function sendPendingBatch() {\n      // clear the timeout if any\n      if (pendingBatchTimeout) {\n        clearTimeout(pendingBatchTimeout);\n        pendingBatchTimeout = null;\n      }\n\n      // prepare the requests array (we know the size)\n      const requests = new Array(pendingBatch.length);\n      const activeBatch = pendingBatch.slice().map((inflight, index) => {\n        // assign the id to the request\n        inflight.request.id = index;\n        // also assign the jsonrpc version\n        inflight.request.jsonrpc = \"2.0\";\n        // assing the request to the requests array (so we don't have to map it again later)\n        requests[index] = inflight.request;\n        return inflight;\n      });\n      // reset pendingBatch to empty\n      pendingBatch = [];\n\n      fetchRpc(rpcUrl, options.client, {\n        requests,\n        requestTimeoutMs: options.config?.requestTimeoutMs,\n      })\n        .then((responses) => {\n          // for each response, resolve the inflight request\n          activeBatch.forEach((inflight, index) => {\n            const response = responses[index];\n            // if we didn't get a response at all, reject the inflight request\n            if (!response) {\n              inflight.reject(new Error(\"No response\"));\n              return;\n            }\n            // handle errors in the response\n            if (response instanceof Error) {\n              inflight.reject(response);\n              return;\n            }\n\n            // handle strings as responses??\n            if (typeof response === \"string\") {\n              inflight.reject(new Error(response));\n              return;\n            }\n\n            if (\"error\" in response) {\n              inflight.reject(response.error);\n              // otherwise, resolve the inflight request\n            } else if (response.method === \"eth_subscription\") {\n              // TODO: handle subscription responses\n              throw new Error(\"Subscriptions not supported yet\");\n            } else {\n              inflight.resolve(response.result);\n            }\n            // remove the inflight request from the inflightRequests map\n            inflightRequests.delete(inflight.requestKey);\n          });\n        })\n        .catch((err) => {\n          // http call failed, reject all inflight requests\n          for (const inflight of activeBatch) {\n            inflight.reject(err);\n            // remove the inflight request from the inflightRequests map\n            inflightRequests.delete(inflight.requestKey);\n          }\n        });\n    }\n\n    // shortcut everything if we do not need to batch\n    if (batchSize === 1) {\n      return async (request) => {\n        // we can hard-code the id and jsonrpc version\n        // we also mutate the request object here to avoid copying it\n        // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n        (request as any).id = 1;\n        // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n        (request as any).jsonrpc = \"2.0\";\n        const rpcResponse = await fetchSingleRpc(rpcUrl, options.client, {\n          request: request,\n          requestTimeoutMs: options.config?.requestTimeoutMs,\n        });\n\n        if (!rpcResponse) {\n          throw new Error(\"No response\");\n        }\n        if (\"error\" in rpcResponse) {\n          throw rpcResponse.error;\n        }\n        return rpcResponse.result;\n      };\n    }\n\n    return async (request) => {\n      const requestKey = rpcRequestKey(request);\n\n      // if the request for this key is already inflight, return the promise directly\n      if (inflightRequests.has(requestKey)) {\n        // biome-ignore lint/style/noNonNullAssertion: the `has` check ensures this is defined\n        return inflightRequests.get(requestKey)!;\n      }\n      // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n      let resolve: (value: any) => void;\n      // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n      let reject: (reason?: any) => void;\n      // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n      const promise = new Promise<any>((resolve_, reject_) => {\n        resolve = resolve_;\n        reject = reject_;\n      });\n      inflightRequests.set(requestKey, promise);\n      // @ts-expect-error - they *are* definitely assgined within the promise constructor\n      pendingBatch.push({ request, resolve, reject, requestKey });\n      if (batchSize > 1) {\n        // if there is no timeout, set one\n        if (!pendingBatchTimeout) {\n          pendingBatchTimeout = setTimeout(sendPendingBatch, batchTimeoutMs);\n        }\n        // if the batch is full, send it\n        if (pendingBatch.length >= batchSize) {\n          sendPendingBatch();\n        }\n      } else {\n        sendPendingBatch();\n      }\n      return promise;\n    };\n  })();\n\n  rpcClientMap.set(chainId, rpcClient);\n  return rpcClient as EIP1193RequestFn<EIP1474Methods>;\n}\n","import type { ThirdwebClient } from \"../client/client.js\";\nimport { getClientFetch } from \"../utils/fetch.js\";\nimport { stringify } from \"../utils/json.js\";\n\nexport type RpcRequest = {\n  jsonrpc?: \"2.0\";\n  method: string;\n  params?: unknown;\n  id?: number;\n};\n\ntype FetchRpcOptions = {\n  requests: RpcRequest[];\n  requestTimeoutMs?: number;\n};\n\ntype SuccessResult<T> = {\n  method?: never;\n  result: T;\n  error?: never;\n};\ntype ErrorResult<T> = {\n  method?: never;\n  result?: never;\n  error: T;\n};\ntype Subscription<TResult, TError> = {\n  method: \"eth_subscription\";\n  error?: never;\n  result?: never;\n  params: {\n    subscription: string;\n  } & (\n    | {\n        result: TResult;\n        error?: never;\n      }\n    | {\n        result?: never;\n        error: TError;\n      }\n  );\n};\n\ntype RpcResponse<TResult = unknown, TError = unknown> = {\n  jsonrpc: `${number}`;\n  id: number;\n} & (\n  | SuccessResult<TResult>\n  | ErrorResult<TError>\n  | Subscription<TResult, TError>\n);\n\n/**\n * @internal\n */\nexport async function fetchRpc(\n  rpcUrl: string,\n  client: ThirdwebClient,\n  options: FetchRpcOptions,\n): Promise<RpcResponse[]> {\n  const response = await getClientFetch(client)(rpcUrl, {\n    headers: {\n      ...client.config?.rpc?.fetch?.headers,\n      \"Content-Type\": \"application/json\",\n    },\n    body: stringify(options.requests),\n    method: \"POST\",\n    requestTimeoutMs:\n      options.requestTimeoutMs ?? client.config?.rpc?.fetch?.requestTimeoutMs,\n    keepalive: client.config?.rpc?.fetch?.keepalive,\n  });\n\n  if (!response.ok) {\n    response.body?.cancel();\n    throw new Error(\n      `RPC request failed with status ${response.status} - ${response.statusText}`,\n    );\n  }\n\n  if (response.headers.get(\"Content-Type\")?.startsWith(\"application/json\")) {\n    return await response.json();\n  }\n  const text = await response.text();\n  try {\n    return JSON.parse(text);\n  } catch (err) {\n    console.error(\"Error parsing response\", err, text);\n    throw err;\n  }\n}\n\ntype FetchSingleRpcOptions = {\n  request: RpcRequest;\n  requestTimeoutMs?: number;\n};\n\n/**\n * @internal\n */\nexport async function fetchSingleRpc(\n  rpcUrl: string,\n  client: ThirdwebClient,\n  options: FetchSingleRpcOptions,\n): Promise<RpcResponse> {\n  const response = await getClientFetch(client)(rpcUrl, {\n    headers: {\n      ...(client.config?.rpc?.fetch?.headers || {}),\n      \"Content-Type\": \"application/json\",\n    },\n    body: stringify(options.request),\n    method: \"POST\",\n    requestTimeoutMs:\n      options.requestTimeoutMs ?? client.config?.rpc?.fetch?.requestTimeoutMs,\n    keepalive: client.config?.rpc?.fetch?.keepalive,\n  });\n\n  if (!response.ok) {\n    response.body?.cancel();\n    throw new Error(`RPC request failed with status ${response.status}`);\n  }\n  if (response.headers.get(\"Content-Type\")?.startsWith(\"application/json\")) {\n    return await response.json();\n  }\n  const text = await response.text();\n  try {\n    return JSON.parse(text);\n  } catch (err) {\n    console.error(\"Error parsing response\", err, text);\n    throw err;\n  }\n}\n","import {\n  type Abi,\n  type AbiFunction,\n  type AbiParameter,\n  type AbiParametersToPrimitiveTypes,\n  type ExtractAbiFunctionNames,\n  parseAbiItem,\n} from \"abitype\";\nimport { type TransactionRequest, decodeAbiParameters } from \"viem\";\nimport type { ThirdwebContract } from \"../contract/contract.js\";\nimport { isAbiFunction } from \"./utils.js\";\n\nimport type { PrepareTransactionOptions } from \"./prepare-transaction.js\";\nimport type {\n  BaseTransactionOptions,\n  ParamsOption,\n  ParseMethod,\n} from \"./types.js\";\n\nimport { eth_call } from \"../rpc/actions/eth_call.js\";\nimport { getRpcClient } from \"../rpc/rpc.js\";\nimport { encodeAbiParameters } from \"../utils/abi/encodeAbiParameters.js\";\nimport {\n  type PreparedMethod,\n  prepareMethod,\n} from \"../utils/abi/prepare-method.js\";\nimport type { Hex } from \"../utils/encoding/hex.js\";\n\nexport type ReadContractResult<outputs extends readonly AbiParameter[]> = // if the outputs are 0 length, return never, invalid case\n  outputs extends { length: 0 }\n    ? never\n    : outputs extends { length: 1 }\n      ? // if the outputs are 1 length, we'll always return the first element\n        AbiParametersToPrimitiveTypes<outputs>[0]\n      : // otherwise we'll return the array\n        AbiParametersToPrimitiveTypes<outputs>;\n\nexport type ReadContractOptions<\n  TAbi extends Abi = [],\n  TMethod extends\n    | AbiFunction\n    | string\n    | ((\n        contract: ThirdwebContract<TAbi>,\n      ) => Promise<AbiFunction>) = TAbi extends { length: 0 }\n    ? AbiFunction | string\n    : ExtractAbiFunctionNames<TAbi>,\n  TPreparedMethod extends PreparedMethod<\n    ParseMethod<TAbi, TMethod>\n  > = PreparedMethod<ParseMethod<TAbi, TMethod>>,\n> = BaseTransactionOptions<\n  Omit<\n    TransactionRequest,\n    | \"from\"\n    | \"to\"\n    | \"data\"\n    | \"value\"\n    | \"accessList\"\n    | \"gas\"\n    | \"gasPrice\"\n    | \"maxFeePerGas\"\n    | \"maxPriorityFeePerGas\"\n    | \"nonce\"\n  > & {\n    method: TMethod | TPreparedMethod;\n  } & ParamsOption<TPreparedMethod[1]> &\n    Omit<PrepareTransactionOptions, \"to\" | \"data\" | \"chain\" | \"client\">,\n  TAbi\n>;\n\n/**\n * Reads data from a smart contract.\n * @param options - The transaction options.\n * @returns A promise that resolves with the result of the read transaction.\n * @transaction\n * @example\n * ```ts\n * import { readContract } from \"thirdweb\";\n * const result = await readContract({\n *  contract,\n *  method: \"totalSupply\",\n * });\n * ```\n */\nexport async function readContract<\n  const TAbi extends Abi,\n  const TMethod extends TAbi extends {\n    length: 0;\n  }\n    ?\n        | AbiFunction\n        | `function ${string}`\n        | ((contract: ThirdwebContract<TAbi>) => Promise<AbiFunction>)\n    : ExtractAbiFunctionNames<TAbi>,\n  const TPreparedMethod extends PreparedMethod<\n    ParseMethod<TAbi, TMethod>\n  > = PreparedMethod<ParseMethod<TAbi, TMethod>>,\n>(\n  options: ReadContractOptions<TAbi, TMethod, TPreparedMethod>,\n): Promise<ReadContractResult<TPreparedMethod[2]>> {\n  type ParsedMethod_ = ParseMethod<TAbi, TMethod>;\n  type PreparedMethod_ = PreparedMethod<ParsedMethod_>;\n  const { contract, method, params } = options;\n\n  const resolvePreparedMethod = async () => {\n    if (Array.isArray(method)) {\n      return method as PreparedMethod_;\n    }\n    if (isAbiFunction(method)) {\n      return prepareMethod(method as ParsedMethod_) as PreparedMethod_;\n    }\n\n    if (typeof method === \"function\") {\n      return prepareMethod(\n        // @ts-expect-error - we're sure it's a function\n        (await method(contract)) as ParsedMethod_,\n      ) as PreparedMethod_;\n    }\n    // if the method starts with the string `function ` we always will want to try to parse it\n    if (typeof method === \"string\" && method.startsWith(\"function \")) {\n      // @ts-expect-error - method *is* string in this case\n      const abiItem = parseAbiItem(method);\n      if (abiItem.type === \"function\") {\n        return prepareMethod(abiItem as ParsedMethod_) as PreparedMethod_;\n      }\n      throw new Error(`\"method\" passed is not of type \"function\"`);\n    }\n    // check if we have a \"abi\" on the contract\n    if (contract.abi && contract.abi?.length > 0) {\n      // extract the abiFunction from it\n      const abiFunction = contract.abi?.find(\n        (item) => item.type === \"function\" && item.name === method,\n      );\n      // if we were able to find it -> return it\n      if (abiFunction) {\n        return prepareMethod(abiFunction as ParsedMethod_) as PreparedMethod_;\n      }\n    }\n    throw new Error(`Could not resolve method \"${method}\".`);\n  };\n\n  // resolve in parallel\n  const [resolvedPreparedMethod, resolvedParams] = await Promise.all([\n    resolvePreparedMethod(),\n    typeof params === \"function\" ? params() : params,\n  ]);\n\n  let encodedData: Hex;\n\n  // if we have no inputs, we know it's just the signature\n  if (resolvedPreparedMethod[1].length === 0) {\n    encodedData = resolvedPreparedMethod[0];\n  } else {\n    // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n    // we can do this because we know the specific formats of the values\n    encodedData = (resolvedPreparedMethod[0] +\n      encodeAbiParameters(\n        resolvedPreparedMethod[1],\n        // @ts-expect-error - TODO: fix this type issue\n        resolvedParams,\n      ).slice(2)) as `${(typeof resolvedPreparedMethod)[0]}${string}`;\n  }\n\n  const rpcRequest = getRpcClient({\n    chain: contract.chain,\n    client: contract.client,\n  });\n\n  const result = await eth_call(rpcRequest, {\n    data: encodedData,\n    to: contract.address,\n  });\n  // use the prepared method to decode the result\n  const decoded = decodeAbiParameters(resolvedPreparedMethod[2], result);\n  if (Array.isArray(decoded) && decoded.length === 1) {\n    return decoded[0];\n  }\n\n  return decoded as ReadContractResult<TPreparedMethod[2]>;\n}\n","import type {\n  BlockTag,\n  EIP1193RequestFn,\n  EIP1474Methods,\n  Hex,\n  RpcStateMapping,\n  RpcStateOverride,\n  RpcTransactionRequest,\n} from \"viem\";\nimport { numberToHex } from \"../../utils/encoding/hex.js\";\n\ntype StateOverride = Record<\n  string,\n  {\n    /**\n     * Fake balance to set for the account before executing the call.\n     */\n    balance?: bigint;\n    /**\n     * Fake nonce to set for the account before executing the call.\n     */\n    nonce?: number;\n    /**\n     * Fake EVM bytecode to inject into the account before executing the call.\n     */\n    code?: Hex;\n    /**\n     * Fake key-value mapping to override **all** slots in the account storage before executing the call.\n     */\n    state?: RpcStateMapping;\n    /**\n     * Fake key-value mapping to override **individual** slots in the account storage before executing the call.\n     */\n    stateDiff?: RpcStateMapping;\n  }\n>;\n\nfunction encodeStateOverrides(overrides: StateOverride): RpcStateOverride {\n  return Object.fromEntries(\n    Object.entries(overrides).map(([address, override]) => {\n      return [\n        address,\n        {\n          balance: override.balance ? numberToHex(override.balance) : undefined,\n          nonce: override.nonce ? numberToHex(override.nonce) : undefined,\n          code: override.code,\n          state: override.state,\n          stateDiff: override.stateDiff,\n        },\n      ];\n    }),\n  );\n}\n\n/**\n * Executes a call or a transaction on the Ethereum network.\n * @param request - The EIP1193 request function.\n * @param params - The parameters for the call or transaction.\n * @returns A promise that resolves to the result of the call or transaction.\n * @rpc\n * @example\n * ```ts\n * import { getRpcClient, eth_call } from \"thirdweb/rpc\";\n * const rpcRequest = getRpcClient({ client, chain });\n * const result = await eth_call(rpcRequest, {\n *  to: \"0x...\",\n *  ...\n * });\n * ```\n */\nexport async function eth_call(\n  request: EIP1193RequestFn<EIP1474Methods>,\n  params: Partial<RpcTransactionRequest> & {\n    blockNumber?: bigint | number;\n    blockTag?: BlockTag;\n    stateOverrides?: StateOverride;\n  },\n): Promise<Hex> {\n  const { blockNumber, blockTag, ...txRequest } = params;\n  const blockNumberHex = blockNumber ? numberToHex(blockNumber) : undefined;\n  // default to \"latest\" if no block is provided\n  const block = blockNumberHex || blockTag || \"latest\";\n\n  return await request({\n    method: \"eth_call\",\n    params: params.stateOverrides\n      ? [\n          txRequest as Partial<RpcTransactionRequest>,\n          block,\n          encodeStateOverrides(params.stateOverrides),\n        ]\n      : [txRequest as Partial<RpcTransactionRequest>, block],\n  });\n}\n","import { readContract } from \"../../../../../transaction/read-contract.js\";\nimport type { BaseTransactionOptions } from \"../../../../../transaction/types.js\";\n\nimport { decodeAbiParameters } from \"viem\";\nimport type { Hex } from \"../../../../../utils/encoding/hex.js\";\nimport type { ThirdwebContract } from \"../../../../../contract/contract.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\n\nexport const FN_SELECTOR = \"0x313ce567\" as const;\nconst FN_INPUTS = [] as const;\nconst FN_OUTPUTS = [\n  {\n    type: \"uint8\",\n  },\n] as const;\n\n/**\n * Checks if the `decimals` method is supported by the given contract.\n * @param contract The ThirdwebContract.\n * @returns A promise that resolves to a boolean indicating if the `decimals` method is supported.\n * @extension ERC20\n * @example\n * ```ts\n * import { isDecimalsSupported } from \"thirdweb/extensions/erc20\";\n *\n * const supported = await isDecimalsSupported(contract);\n * ```\n */\nexport async function isDecimalsSupported(contract: ThirdwebContract<any>) {\n  return detectMethod({\n    contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Decodes the result of the decimals function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension ERC20\n * @example\n * ```ts\n * import { decodeDecimalsResult } from \"thirdweb/extensions/erc20\";\n * const result = decodeDecimalsResult(\"...\");\n * ```\n */\nexport function decodeDecimalsResult(result: Hex) {\n  return decodeAbiParameters(FN_OUTPUTS, result)[0];\n}\n\n/**\n * Calls the \"decimals\" function on the contract.\n * @param options - The options for the decimals function.\n * @returns The parsed result of the function call.\n * @extension ERC20\n * @example\n * ```ts\n * import { decimals } from \"thirdweb/extensions/erc20\";\n *\n * const result = await decimals({\n *  contract,\n * });\n *\n * ```\n */\nexport async function decimals(options: BaseTransactionOptions) {\n  return readContract({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: [],\n  });\n}\n","import type { BaseTransactionOptions } from \"../../../transaction/types.js\";\nimport { withCache } from \"../../../utils/promise/withCache.js\";\nimport { decimals as generatedDecimals } from \"../__generated__/IERC20/read/decimals.js\";\n\n/**\n * Retrieves the number of decimal places for a given ERC20 contract.\n * @param options - The options for the transaction.\n * @returns A promise that resolves to the number of decimal places.\n * @extension ERC20\n * @example\n * ```ts\n * import { decimals } from \"thirdweb/extensions/erc20\";\n *\n * const tokenDecimals = await decimals({ contract });\n * ```\n */\nexport async function decimals(\n  options: BaseTransactionOptions,\n): Promise<number> {\n  return withCache(() => generatedDecimals(options), {\n    cacheKey: `${options.contract.chain.id}:${options.contract.address}:decimals`,\n    // can never change, so cache forever\n    cacheTime: Number.POSITIVE_INFINITY,\n  });\n}\n"],"names":["promiseCache","Map","responseCache","async","withCache","fn","_ref","cacheKey","cacheTime","Number","POSITIVE_INFINITY","cache","buildCache","cacheKey_","clear","delete","get","set","data","promise","response","getCache","Date","getTime","created","formatAbiParams","params","includeName","arguments","length","undefined","map","param","type","startsWith","components","slice","name","formatAbiParam","join","BaseError","AbiDecodingDataSizeTooSmallError","constructor","_ref4","size","super","metaMessages","Object","defineProperty","this","AbiDecodingZeroDataError","InvalidAbiDecodingTypeError","_ref19","docsPath","LruMap","maxSize","key","value","keys","next","checksumAddressCache","checksumAddress","address_","chainId","has","hexAddress","toLowerCase","substring","hash","keccak256","stringToBytes","address","split","i","toUpperCase","result","NegativeOffsetError","offset","PositionOutOfBoundsError","_ref2","position","RecursiveReadLimitExceededError","_ref3","count","limit","staticCursor","bytes","Uint8Array","dataView","DataView","ArrayBuffer","positionReadCount","recursiveReadCount","recursiveReadLimit","assertReadLimit","assertPosition","decrementPosition","getReadCount","incrementPosition","inspectByte","position_","inspectBytes","subarray","inspectUint8","inspectUint16","getUint16","inspectUint24","getUint8","inspectUint32","getUint32","pushByte","byte","pushBytes","pushUint8","pushUint16","setUint16","pushUint24","setUint8","pushUint32","setUint32","readByte","_touch","readBytes","readUint8","readUint16","readUint24","readUint32","remaining","setPosition","oldPosition","trim","hexOrBytes","dir","replace","sliceLength","toString","bytesToBigInt","opts","assertSize","hex","bytesToHex","hexToBigInt","bytesToBool","bytes_","InvalidBytesBooleanError","Boolean","bytesToNumber","hexToNumber","bytesToString","TextDecoder","decode","getArrayComponents","matches","match","decodeAbiParameters","hexToBytes","cursor","create","buffer","byteOffset","byteLength","createCursor","consumed","values","consumed_","decodeParameter","staticPosition","push","arrayComponents","start","sizeOfOffset","startOfData","sizeOfLength","dynamicChild","hasDynamicChild","decodeArray","hasUnnamedChild","some","_ref5","component","decodeTuple","sliceBytes","decodeAddress","decodeBool","_","parseInt","decodeBytes","signed","decodeNumber","_ref6","decodeString","endsWith","RPC_CLIENT_MAP","WeakMap","DEFAULT_MAX_BATCH_SIZE","DEFAULT_BATCH_TIMEOUT_MS","getRpcClient","options","rpcClientMap","client","getRpcClientMap","chain","id","rpc","rpcClient","rpcUrl","getRpcUrlForChain","batchSize","config","maxBatchSize","batchTimeoutMs","inflightRequests","pendingBatch","pendingBatchTimeout","sendPendingBatch","clearTimeout","requests","Array","activeBatch","inflight","index","request","jsonrpc","getClientFetch","headers","fetch","body","stringify","method","requestTimeoutMs","keepalive","ok","cancel","Error","status","statusText","json","text","JSON","parse","err","console","error","fetchRpc","then","responses","forEach","reject","resolve","requestKey","catch","rpcResponse","fetchSingleRpc","rpcRequestKey","Promise","resolve_","reject_","setTimeout","readContract","contract","resolvedPreparedMethod","resolvedParams","all","isArray","isAbiFunction","prepareMethod","abiItem","parseAbiItem","abi","abiFunction","find","item","resolvePreparedMethod","encodedData","encodeAbiParameters","rpcRequest","blockNumber","blockTag","txRequest","block","numberToHex","stateOverrides","overrides","fromEntries","entries","override","balance","nonce","code","state","stateDiff","eth_call","to","decoded","FN_SELECTOR","FN_INPUTS","FN_OUTPUTS","decimals","generatedDecimals"],"sourceRoot":""}