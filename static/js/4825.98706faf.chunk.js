"use strict";(self.webpackChunkmango=self.webpackChunkmango||[]).push([[4825],{26680:(t,a,e)=>{e.d(a,{D:()=>g,F:()=>d,I:()=>c,a:()=>p,b:()=>f,c:()=>h,f:()=>l,g:()=>y,u:()=>u});var r=e(16487),n=e(89106),s=e(2776),o=e(10974),i=e(26382).Buffer;const c=(()=>n.arrayify("0x80ac58cd"))(),p=(()=>n.arrayify("0xd9b67a26"))(),d={name:"Failed to load NFT metadata"};async function l(t,a,e){if(a.startsWith("data:application/json;base64")&&"undefined"!==typeof i){const e=a.split(",")[1],n=JSON.parse(i.from(e,"base64").toString("utf-8"));return r.a.parse({...n,id:s.gH.from(t).toString(),uri:a})}const o=a.replace("{id}",n.hexZeroPad(s.gH.from(t).toHexString(),32).slice(2));let c;try{c=await e.downloadJSON(o)}catch(p){const r=a.replace("{id}",s.gH.from(t).toString());try{c=await e.downloadJSON(r)}catch(l){console.warn(`failed to get token metadata: ${JSON.stringify({tokenId:t.toString(),tokenUri:a})} -- falling back to default metadata`),c=d}}return r.a.parse({...c,id:s.gH.from(t).toString(),uri:a})}async function h(t,a,n,i){let h;const f=(await e.e(4811).then(e.t.bind(e,94811,19))).default,u=new o.NZ(t,f,a),[y,g]=await Promise.all([u.supportsInterface(c),u.supportsInterface(p)]);if(y){const r=(await Promise.resolve().then(e.t.bind(e,1024,19))).default,s=new o.NZ(t,r,a);h=await s.tokenURI(n)}else{if(!g)throw Error("Contract must implement ERC 1155 or ERC 721.");{const r=(await Promise.resolve().then(e.t.bind(e,51146,19))).default,s=new o.NZ(t,r,a);h=await s.uri(n)}}return h?l(n,h,i):r.a.parse({...d,id:s.gH.from(n).toString(),uri:""})}async function f(t,a){return"string"===typeof t?t:await a.upload(r.C.parse(t))}async function u(t,a,e,n){if(function(t){return void 0===t.find((t=>"string"!==typeof t))}(t))return t;if(function(t){return void 0===t.find((t=>"object"!==typeof t))}(t)){return await a.uploadBatch(t.map((t=>r.C.parse(t))),{rewriteFileNames:{fileStartNumber:e||0},onProgress:n?.onProgress})}throw new Error("NFT metadatas must all be of the same type (all URI or all NFTMetadataInput)")}function y(t){const a=t[0].substring(0,t[0].lastIndexOf("/"));for(let e=0;e<t.length;e++){const r=t[e].substring(0,t[e].lastIndexOf("/"));if(a!==r)throw new Error(`Can only create batches with the same base URI for every entry in the batch. Expected '${a}' but got '${r}'`)}return a.replace(/\/$/,"")+"/"}const g=100},74825:(t,a,e)=>{e.d(a,{C:()=>w,D:()=>m,a:()=>I,c:()=>W});var r=e(36859),n=e(3494),s=e(70592),o=e(33409),i=e(2614),c=e(84794),p=e(50992),d=e(89106),l=e(2776),h=e(10974),f=e(16487),u=e(26680),y=e(33820),g=e(4265);class w{featureName=(()=>s.d5.name)();constructor(t,a){this.contractWrapper=t,this.metadata=a}async getDefaultRoyaltyInfo(){const[t,a]=await this.contractWrapper.read("getDefaultRoyaltyInfo",[]);return s.bF.parseAsync({fee_recipient:t,seller_fee_basis_points:a})}async getTokenRoyaltyInfo(t){const[a,e]=await this.contractWrapper.read("getRoyaltyInfoForToken",[t]);return s.bF.parseAsync({fee_recipient:a,seller_fee_basis_points:e})}setDefaultRoyaltyInfo=(()=>(0,n.f)((async t=>{const a=await this.metadata.get(),e=await this.metadata.parseInputMetadata({...a,...t}),s=await this.metadata._parseAndUploadMetadata(e);if((0,r.h)("setContractURI",this.contractWrapper)){const t=new o.C(this.contractWrapper),a=[t.encode("setDefaultRoyaltyInfo",[e.fee_recipient,e.seller_fee_basis_points]),t.encode("setContractURI",[s])];return n.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[a],parse:t=>({receipt:t,data:()=>this.getDefaultRoyaltyInfo()})})}throw new Error("Updating royalties requires implementing ContractMetadata in your contract to support marketplaces like OpenSea.")})))();setTokenRoyaltyInfo=(()=>(0,n.f)((async(t,a)=>{const e=s.bF.parse(a);return n.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setRoyaltyInfoForToken",args:[t,e.fee_recipient,e.seller_fee_basis_points],parse:t=>({receipt:t,data:()=>this.getDefaultRoyaltyInfo()})})})))()}class m{constructor(t,a,e,r){this.featureName=e,this.nextTokenIdToMintFn=r,this.contractWrapper=t,this.storage=a}createDelayedRevealBatch=(()=>(0,n.f)((async(t,a,e,r)=>{if(!e)throw new Error("Password is required");const s=await this.storage.uploadBatch([f.C.parse(t)],{rewriteFileNames:{fileStartNumber:0}}),o=(0,u.g)(s),d=await this.nextTokenIdToMintFn(),l=await this.storage.uploadBatch(a.map((t=>f.C.parse(t))),{onProgress:r?.onProgress,rewriteFileNames:{fileStartNumber:d.toNumber()}}),h=(0,u.g)(l),y=await this.contractWrapper.read("getBaseURICount",[]),g=await this.hashDelayRevealPassword(y,e),w=await this.contractWrapper.read("encryptDecrypt",[i.YW(h),g]);let m;if(await this.isLegacyContract())m=w;else{const t=await this.contractWrapper.getChainID(),a=c.keccak256(["bytes","bytes","uint256"],[i.YW(h),g,t]);m=p.D.encode(["bytes","bytes32"],[w,a])}return n.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"lazyMint",args:[l.length,o.endsWith("/")?o:`${o}/`,m],parse:t=>{const a=this.contractWrapper.parseLogs("TokensLazyMinted",t?.logs),e=a[0].args.startTokenId,r=a[0].args.endTokenId,n=[];for(let s=e;s.lte(r);s=s.add(1))n.push({id:s,receipt:t});return n}})})))();reveal=(()=>(0,n.f)((async(t,a)=>{if(!a)throw new Error("Password is required");const e=await this.hashDelayRevealPassword(t,a);try{const a=await this.contractWrapper.callStatic().reveal(t,e);if(!a.includes("://")||!a.endsWith("/"))throw new Error("invalid password")}catch(r){throw new Error("invalid password")}return n.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"reveal",args:[t,e]})})))();async getBatchesToReveal(){const t=await this.contractWrapper.read("getBaseURICount",[]);if(t.isZero())return[];const a=Array.from(Array(t.toNumber()).keys()),e=await Promise.all(a.map((t=>{if((0,r.h)("getBatchIdAtIndex",this.contractWrapper))return this.contractWrapper.read("getBatchIdAtIndex",[t]);if((0,r.h)("baseURIIndices",this.contractWrapper))return this.contractWrapper.read("baseURIIndices",[t]);throw new Error("Contract does not have getBatchIdAtIndex or baseURIIndices.")}))),n=e.slice(0,e.length-1),s=await Promise.all(Array.from([0,...n]).map((t=>this.getNftMetadata(t.toString())))),o=await this.isLegacyContract(),i=(await Promise.all(Array.from([...e]).map((t=>o?this.getLegacyEncryptedData(t):this.contractWrapper.read("encryptedData",[t]))))).map((t=>{if(d.hexDataLength(t)>0){if(o)return t;return p.D.decode(["bytes","bytes32"],t)[0]}return t}));return s.map(((t,a)=>({batchId:l.gH.from(a),batchUri:t.uri,placeholderMetadata:t}))).filter(((t,a)=>d.hexDataLength(i[a])>0))}async hashDelayRevealPassword(t,a){const e=await this.contractWrapper.getChainID(),r=this.contractWrapper.address;return c.keccak256(["string","uint256","uint256","address"],[a,e,t,r])}async getNftMetadata(t){return(0,u.c)(this.contractWrapper.address,this.contractWrapper.getProvider(),t,this.storage)}async isLegacyContract(){if((0,r.h)("contractVersion",this.contractWrapper))try{return await this.contractWrapper.read("contractVersion",[])<=2}catch(t){return!1}return!1}async getLegacyEncryptedData(t){const a=(await e.e(4601).then(e.t.bind(e,34601,19))).default,r=new h.NZ(this.contractWrapper.address,a,this.contractWrapper.getProvider()),n=await r.functions.encryptedBaseURI(t);return n.length>0?n[0]:"0x"}}async function W(t,a,e,r,n){let o={};const i=r||s.aV,c=(await(0,g.n)(t.getProvider(),a,i)).mul(e);return c.gt(0)&&(i===s.aV?o={value:c}:i!==s.aV&&n&&await(0,y.a)(t,i,c,e,0)),o}class I{featureName=(()=>s.d6.name)();constructor(t){this.contractWrapper=t}async get(){return this.contractWrapper.read("owner",[])}set=(()=>(0,n.f)((async t=>{const a=await(0,s.aL)(t);return n.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setOwner",args:[a]})})))()}}}]);
//# sourceMappingURL=4825.98706faf.chunk.js.map