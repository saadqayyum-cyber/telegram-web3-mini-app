{"version":3,"file":"static/js/5341.43636b0d.chunk.js","mappings":"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","sources":["../node_modules/@thirdweb-dev/sdk/dist/multiwrap-2e713f6c.browser.esm.js","../node_modules/@thirdweb-dev/sdk/dist/erc-721-standard-4c4125d2.browser.esm.js","../node_modules/@thirdweb-dev/sdk/dist/marketplace-e3129e2f.browser.esm.js","../node_modules/@thirdweb-dev/sdk/dist/hasERC20Allowance-654a940b.browser.esm.js"],"sourcesContent":["import { utils } from 'ethers';\nimport { C as ContractEncoder, f as fetchCurrencyMetadata } from './fetchCurrencyValue-32d08b05.browser.esm.js';\nimport { h as hasERC20Allowance } from './hasERC20Allowance-654a940b.browser.esm.js';\nimport { n as normalizePriceValue } from './normalizePriceValue-9851c0eb.browser.esm.js';\nimport { dI as MULTIWRAP_CONTRACT_ROLES, cs as ContractWrapper, bj as AbiSchema, dJ as MultiwrapContractSchema, aL as resolveAddress } from './index-33cd3415.browser.esm.js';\nimport { i as isTokenApprovedForTransfer } from './marketplace-e3129e2f.browser.esm.js';\nimport { b as uploadOrExtractURI } from './QueryParams-32a56510.browser.esm.js';\nimport { f as buildTransactionFunction, T as Transaction } from './transactions-72f9603c.browser.esm.js';\nimport { C as ContractMetadata, b as ContractAppURI, G as GasCostEstimator, a as ContractEvents } from './contract-appuri-5c40af52.browser.esm.js';\nimport { C as ContractRoyalty, a as ContractOwner } from './contract-owner-49e75547.browser.esm.js';\nimport { C as ContractRoles } from './contract-roles-71988d2e.browser.esm.js';\nimport { S as StandardErc721 } from './erc-721-standard-4c4125d2.browser.esm.js';\nimport 'zod';\nimport '@thirdweb-dev/chains';\nimport '@thirdweb-dev/crypto';\nimport 'tiny-invariant';\nimport 'bn.js';\nimport 'bs58';\nimport '@thirdweb-dev/contracts-js/dist/abis/IBurnableERC20.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IDrop.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IDropERC20_V2.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IDropSinglePhase.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IDropSinglePhase_V1.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IERC20.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IERC20Permit.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IMintableERC20.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IMulticall.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/ISignatureMintERC20.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IERC20Metadata.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IBurnableERC721.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IClaimableERC721.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IDelayedReveal.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IDropERC721_V3.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IERC721.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IERC721Enumerable.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IERC721AQueryableUpgradeable.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IERC721Supply.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/ILazyMint.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IMintableERC721.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/ISignatureMintERC721.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/ISignatureMintERC721_V1.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/LazyMintWithTier_V1.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/SharedMetadata.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/zora_IERC721Drop.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/ILoyaltyCard.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/INFTMetadata.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IERC721Metadata.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IBurnableERC1155.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IClaimableERC1155.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IDrop1155.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IDropERC1155_V2.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IDropSinglePhase1155.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IDropSinglePhase1155_V1.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IERC1155.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IERC1155Metadata.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IERC1155Supply.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IERC1155Enumerable.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IMintableERC1155.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/ISignatureMintERC1155.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IERC2771Context.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IAppURI.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IContractMetadata.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IDirectListings.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IEnglishAuctions.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IOffers.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IPackVRFDirect.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IPermissions.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IPermissionsEnumerable.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IPlatformFee.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IPrimarySale.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IRoyalty.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/Ownable.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IAirdropERC20.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IAirdropERC721.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IAirdropERC1155.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IAccountFactoryCore.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IAccountPermissions.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IAccountPermissions_V1.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IAccount.json';\nimport 'ethers/lib/utils';\nimport 'eventemitter3';\nimport './setErc20Allowance-7f76f677.browser.esm.js';\nimport '@thirdweb-dev/storage';\nimport './signature-d3ea643d.browser.esm.js';\nimport '@thirdweb-dev/merkletree';\nimport './assertEnabled-d1700f0b.browser.esm.js';\nimport 'uuid';\nimport './erc-721-27306550.browser.esm.js';\nimport './drop-claim-conditions-e6f2abbf.browser.esm.js';\nimport 'fast-deep-equal';\n\n/**\n * Multiwrap lets you wrap any number of ERC20, ERC721 and ERC1155 tokens you own into a single wrapped token bundle.\n *\n * @example\n *\n * ```javascript\n * import { ThirdwebSDK } from \"@thirdweb-dev/sdk\";\n *\n * const sdk = new ThirdwebSDK(\"{{chainName}}\");\n * const contract = await sdk.getContract(\"{{contract_address}}\", \"multiwrap\");\n * ```\n *\n * @beta\n */\n// TODO create extension wrappers for this\nclass Multiwrap extends StandardErc721 {\n  static contractRoles = MULTIWRAP_CONTRACT_ROLES;\n\n  /**\n   * Configure royalties\n   * @remarks Set your own royalties for the entire contract or per token\n   * @example\n   * ```javascript\n   * // royalties on the whole contract\n   * contract.royalties.setDefaultRoyaltyInfo({\n   *   seller_fee_basis_points: 100, // 1%\n   *   fee_recipient: \"0x...\"\n   * });\n   * // override royalty for a particular token\n   * contract.royalties.setTokenRoyaltyInfo(tokenId, {\n   *   seller_fee_basis_points: 500, // 5%\n   *   fee_recipient: \"0x...\"\n   * });\n   * ```\n   */\n\n  constructor(network, address, storage) {\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    let abi = arguments.length > 4 ? arguments[4] : undefined;\n    let chainId = arguments.length > 5 ? arguments[5] : undefined;\n    let contractWrapper = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : new ContractWrapper(network, address, abi, options, storage);\n    super(contractWrapper, storage, chainId);\n    this.abi = AbiSchema.parse(abi || []);\n    this.metadata = new ContractMetadata(this.contractWrapper, MultiwrapContractSchema, this.storage);\n    this.app = new ContractAppURI(this.contractWrapper, this.metadata, this.storage);\n    this.roles = new ContractRoles(this.contractWrapper, Multiwrap.contractRoles);\n    this.encoder = new ContractEncoder(this.contractWrapper);\n    this.estimator = new GasCostEstimator(this.contractWrapper);\n    this.events = new ContractEvents(this.contractWrapper);\n    this.royalties = new ContractRoyalty(this.contractWrapper, this.metadata);\n    this.owner = new ContractOwner(this.contractWrapper);\n  }\n\n  /** ******************************\n   * READ FUNCTIONS\n   *******************************/\n\n  /**\n   * Get the contents of a wrapped token bundle\n   * @example\n   * ```javascript\n   * const contents = await contract.getWrappedContents(wrappedTokenId);\n   * console.log(contents.erc20Tokens);\n   * console.log(contents.erc721Tokens);\n   * console.log(contents.erc1155Tokens);\n   * ```\n   * @param wrappedTokenId - the id of the wrapped token bundle\n   */\n  async getWrappedContents(wrappedTokenId) {\n    const wrappedTokens = await this.contractWrapper.read(\"getWrappedContents\", [wrappedTokenId]);\n    const erc20Tokens = [];\n    const erc721Tokens = [];\n    const erc1155Tokens = [];\n    for (const token of wrappedTokens) {\n      switch (token.tokenType) {\n        case 0:\n          {\n            const tokenMetadata = await fetchCurrencyMetadata(this.contractWrapper.getProvider(), token.assetContract);\n            erc20Tokens.push({\n              contractAddress: token.assetContract,\n              quantity: utils.formatUnits(token.totalAmount, tokenMetadata.decimals)\n            });\n            break;\n          }\n        case 1:\n          {\n            erc721Tokens.push({\n              contractAddress: token.assetContract,\n              tokenId: token.tokenId\n            });\n            break;\n          }\n        case 2:\n          {\n            erc1155Tokens.push({\n              contractAddress: token.assetContract,\n              tokenId: token.tokenId,\n              quantity: token.totalAmount.toString()\n            });\n            break;\n          }\n      }\n    }\n    return {\n      erc20Tokens,\n      erc721Tokens,\n      erc1155Tokens\n    };\n  }\n\n  /** ******************************\n   * WRITE FUNCTIONS\n   *******************************/\n\n  /**\n   * Wrap any number of ERC20/ERC721/ERC1155 tokens into a single wrapped token\n   * @example\n   * ```javascript\n   * const tx = await contract.wrap({\n   *   erc20Tokens: [{\n   *     contractAddress: \"0x...\",\n   *     quantity: \"0.8\"\n   *   }],\n   *   erc721Tokens: [{\n   *     contractAddress: \"0x...\",\n   *     tokenId: \"0\"\n   *   }],\n   *   erc1155Tokens: [{\n   *     contractAddress: \"0x...\",\n   *     tokenId: \"1\",\n   *     quantity: \"2\"\n   *   }]\n   * }, {\n   *     name: \"Wrapped bundle\",\n   *     description: \"This is a wrapped bundle of tokens and NFTs\",\n   *     image: \"ipfs://...\",\n   * });\n   * const receipt = tx.receipt(); // the transaction receipt\n   * const wrappedTokenId = tx.id; // the id of the wrapped token bundle\n   * ```\n   * @param contents - the contents to wrap\n   * @param wrappedTokenMetadata - metadata to represent the wrapped token bundle\n   * @param recipientAddress - Optional. The address to send the wrapped token bundle to\n   */\n  wrap = /* @__PURE__ */buildTransactionFunction(async (contents, wrappedTokenMetadata, recipientAddress) => {\n    const [uri, tokens, recipient] = await Promise.all([uploadOrExtractURI(wrappedTokenMetadata, this.storage), this.toTokenStructList(contents), resolveAddress(recipientAddress ? recipientAddress : await this.contractWrapper.getSignerAddress())]);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"wrap\",\n      args: [tokens, uri, recipient],\n      parse: receipt => {\n        const event = this.contractWrapper.parseLogs(\"TokensWrapped\", receipt?.logs);\n        if (event.length === 0) {\n          throw new Error(\"TokensWrapped event not found\");\n        }\n        const tokenId = event[0].args.tokenIdOfWrappedToken;\n        return {\n          id: tokenId,\n          receipt,\n          data: () => this.get(tokenId)\n        };\n      }\n    });\n  });\n\n  /**\n   * Unwrap a wrapped token bundle, and retrieve its contents\n   * @example\n   * ```javascript\n   * await contract.unwrap(wrappedTokenId);\n   * ```\n   * @param wrappedTokenId - the id of the wrapped token bundle\n   * @param recipientAddress - Optional. The address to send the unwrapped tokens to\n   */\n  unwrap = /* @__PURE__ */buildTransactionFunction(async (wrappedTokenId, recipientAddress) => {\n    const recipient = await resolveAddress(recipientAddress ? recipientAddress : await this.contractWrapper.getSignerAddress());\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"unwrap\",\n      args: [wrappedTokenId, recipient]\n    });\n  });\n\n  /** ******************************\n   * PRIVATE FUNCTIONS\n   *******************************/\n\n  async toTokenStructList(contents) {\n    const tokens = [];\n    const provider = this.contractWrapper.getProvider();\n    const owner = await this.contractWrapper.getSignerAddress();\n    if (contents.erc20Tokens) {\n      for (const erc20 of contents.erc20Tokens) {\n        const normalizedQuantity = await normalizePriceValue(provider, erc20.quantity, erc20.contractAddress);\n        const hasAllowance = await hasERC20Allowance(this.contractWrapper, erc20.contractAddress, normalizedQuantity);\n        if (!hasAllowance) {\n          throw new Error(`ERC20 token with contract address \"${erc20.contractAddress}\" does not have enough allowance to transfer.\\n\\nYou can set allowance to the multiwrap contract to transfer these tokens by running:\\n\\nawait sdk.getToken(\"${erc20.contractAddress}\").setAllowance(\"${this.getAddress()}\", ${erc20.quantity});\\n\\n`);\n        }\n        tokens.push({\n          assetContract: erc20.contractAddress,\n          totalAmount: normalizedQuantity,\n          tokenId: 0,\n          tokenType: 0\n        });\n      }\n    }\n    if (contents.erc721Tokens) {\n      for (const erc721 of contents.erc721Tokens) {\n        const isApproved = await isTokenApprovedForTransfer(this.contractWrapper.getProvider(), this.getAddress(), erc721.contractAddress, erc721.tokenId, owner);\n        if (!isApproved) {\n          throw new Error(`ERC721 token \"${erc721.tokenId}\" with contract address \"${erc721.contractAddress}\" is not approved for transfer.\\n\\nYou can give approval the multiwrap contract to transfer this token by running:\\n\\nawait sdk.getNFTCollection(\"${erc721.contractAddress}\").setApprovalForToken(\"${this.getAddress()}\", ${erc721.tokenId});\\n\\n`);\n        }\n        tokens.push({\n          assetContract: erc721.contractAddress,\n          totalAmount: 0,\n          tokenId: erc721.tokenId,\n          tokenType: 1\n        });\n      }\n    }\n    if (contents.erc1155Tokens) {\n      for (const erc1155 of contents.erc1155Tokens) {\n        const isApproved = await isTokenApprovedForTransfer(this.contractWrapper.getProvider(), this.getAddress(), erc1155.contractAddress, erc1155.tokenId, owner);\n        if (!isApproved) {\n          throw new Error(`ERC1155 token \"${erc1155.tokenId}\" with contract address \"${erc1155.contractAddress}\" is not approved for transfer.\\n\\nYou can give approval the multiwrap contract to transfer this token by running:\\n\\nawait sdk.getEdition(\"${erc1155.contractAddress}\").setApprovalForAll(\"${this.getAddress()}\", true);\\n\\n`);\n        }\n        tokens.push({\n          assetContract: erc1155.contractAddress,\n          totalAmount: erc1155.quantity,\n          tokenId: erc1155.tokenId,\n          tokenType: 2\n        });\n      }\n    }\n    return tokens;\n  }\n\n  /**\n   * @internal\n   */\n  async prepare(method, args, overrides) {\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method,\n      args,\n      overrides\n    });\n  }\n\n  /**\n   * @internal\n   */\n  async call(functionName, args, overrides) {\n    return this.contractWrapper.call(functionName, args, overrides);\n  }\n}\n\nexport { Multiwrap };\n","import { aL as resolveAddress } from './index-33cd3415.browser.esm.js';\nimport { f as buildTransactionFunction, T as Transaction } from './transactions-72f9603c.browser.esm.js';\nimport { E as Erc721 } from './erc-721-27306550.browser.esm.js';\n\n/**\n * Standard ERC721 NFT functions\n * @remarks Basic functionality for a ERC721 contract that handles IPFS storage for you.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * await contract.nft.transfer(walletAddress, tokenId);\n * ```\n * @public\n */\nclass StandardErc721 {\n  get chainId() {\n    return this._chainId;\n  }\n  constructor(contractWrapper, storage, chainId) {\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n    this.erc721 = new Erc721(this.contractWrapper, this.storage, chainId);\n    this._chainId = chainId;\n  }\n\n  /**\n   * @internal\n   */\n  onNetworkUpdated(network) {\n    this.contractWrapper.updateSignerOrProvider(network);\n  }\n  getAddress() {\n    return this.contractWrapper.address;\n  }\n\n  /**\n   * Get all NFTs\n   *\n   * @remarks Get all the data associated with every NFT in this contract.\n   *\n   * By default, returns the first 100 NFTs, use queryParams to fetch more.\n   *\n   * @example\n   * ```javascript\n   * const nfts = await contract.getAll();\n   * console.log(nfts);\n   * ```\n   * @param queryParams - optional filtering to only fetch a subset of results.\n   * @returns The NFT metadata for all NFTs queried.\n   */\n  async getAll(queryParams) {\n    return this.erc721.getAll(queryParams);\n  }\n\n  /**\n   * Get all NFTs owned by a specific wallet\n   *\n   * @remarks Get all the data associated with the NFTs owned by a specific wallet.\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet to get the NFTs of\n   * const address = \"{{wallet_address}}\";\n   * const nfts = await contract.getOwned(address);\n   * console.log(nfts);\n   * ```\n   * @param walletAddress - the wallet address to query, defaults to the connected wallet\n   * @param queryParams - optional filtering to only fetch a subset of results.\n   * @returns The NFT metadata for all NFTs in the contract.\n   */\n  async getOwned(walletAddress, queryParams) {\n    if (walletAddress) {\n      walletAddress = await resolveAddress(walletAddress);\n    }\n    return this.erc721.getOwned(walletAddress, queryParams);\n  }\n\n  /**\n   * Get Owned Token Ids\n   * @remarks Get all the token ids of NFTs owned by a specific wallet (no metadata)\n   */\n  async getOwnedTokenIds(walletAddress) {\n    if (walletAddress) {\n      walletAddress = await resolveAddress(walletAddress);\n    }\n    return this.erc721.getOwnedTokenIds(walletAddress);\n  }\n\n  /**\n   * Get total minted supply count\n   */\n  async totalSupply() {\n    return this.erc721.totalCirculatingSupply();\n  }\n\n  /**\n   * Get a single NFT\n   *\n   * @example\n   * ```javascript\n   * const tokenId = 0;\n   * const nft = await contract.get(tokenId);\n   * ```\n   * @param tokenId - the tokenId of the NFT to retrieve\n   * @returns The NFT metadata\n   */\n  async get(tokenId) {\n    return this.erc721.get(tokenId);\n  }\n\n  /**\n   * Get the current owner of a given NFT within this Contract\n   *\n   * @param tokenId - the tokenId of the NFT\n   * @returns The address of the owner\n   */\n  async ownerOf(tokenId) {\n    return this.erc721.ownerOf(tokenId);\n  }\n\n  /**\n   * Get NFT Balance\n   *\n   * @remarks Get a wallets NFT balance (number of NFTs in this contract owned by the wallet).\n   *\n   * @example\n   * ```javascript\n   * const walletAddress = \"{{wallet_address}}\";\n   * const balance = await contract.balanceOf(walletAddress);\n   * console.log(balance);\n   * ```\n   */\n  async balanceOf(address) {\n    return this.erc721.balanceOf(address);\n  }\n\n  /**\n   * Get NFT Balance for the currently connected wallet\n   */\n  async balance() {\n    return this.erc721.balance();\n  }\n\n  /**\n   * Get whether this wallet has approved transfers from the given operator\n   * @param address - the wallet address\n   * @param operator - the operator address\n   */\n  async isApproved(address, operator) {\n    return this.erc721.isApproved(address, operator);\n  }\n\n  /**\n   * Transfer an NFT\n   *\n   * @remarks Transfer an NFT from the connected wallet to another wallet.\n   *\n   * @example\n   * ```javascript\n   * const walletAddress = \"{{wallet_address}}\";\n   * const tokenId = 0;\n   * await contract.transfer(walletAddress, tokenId);\n   * ```\n   */\n  transfer = /* @__PURE__ */buildTransactionFunction(async (to, tokenId) => {\n    return this.erc721.transfer.prepare(to, tokenId);\n  });\n\n  /**\n   * Approve or remove operator as an operator for the caller. Operators can call transferFrom or safeTransferFrom for any token owned by the caller.\n   * @param operator - the operator's address\n   * @param approved - whether to approve or remove\n   *\n   * @internal\n   */\n  setApprovalForAll = /* @__PURE__ */buildTransactionFunction(async (operator, approved) => {\n    return this.erc721.setApprovalForAll.prepare(operator, approved);\n  });\n\n  /**\n   * Approve an operator for the NFT owner. Operators can call transferFrom or safeTransferFrom for the specified token.\n   * @param operator - the operator's address\n   * @param tokenId - the tokenId to give approval for\n   *\n   * @internal\n   */\n  setApprovalForToken = /* @__PURE__ */buildTransactionFunction(async (operator, tokenId) => {\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"approve\",\n      args: [await resolveAddress(operator), tokenId]\n    });\n  });\n}\n\nexport { StandardErc721 as S };\n","import { Contract, BigNumber } from 'ethers';\nimport invariant from 'tiny-invariant';\nimport { I as InterfaceId_IERC721, a as InterfaceId_IERC1155, D as DEFAULT_QUERY_ALL_COUNT } from './QueryParams-32a56510.browser.esm.js';\nimport { cs as ContractWrapper, dE as MAX_BPS } from './index-33cd3415.browser.esm.js';\nimport { a as fetchCurrencyValue } from './fetchCurrencyValue-32d08b05.browser.esm.js';\n\n/**\n * This method checks if the given token is approved for the transferrerContractAddress contract.\n * This is particularly useful for contracts that need to transfer NFTs on the users' behalf\n *\n * @internal\n * @param provider - The connected provider\n * @param transferrerContractAddress - The address of the marketplace contract\n * @param assetContract - The address of the asset contract.\n * @param tokenId - The token id of the token.\n * @param owner - The address of the account that owns the token.\n * @returns  True if the transferrerContractAddress is approved on the token, false otherwise.\n */\nasync function isTokenApprovedForTransfer(provider, transferrerContractAddress, assetContract, tokenId, owner) {\n  try {\n    const ERC165Abi = (await import('@thirdweb-dev/contracts-js/dist/abis/IERC165.json')).default;\n    const erc165 = new Contract(assetContract, ERC165Abi, provider);\n    const [isERC721, isERC1155] = await Promise.all([erc165.supportsInterface(InterfaceId_IERC721), erc165.supportsInterface(InterfaceId_IERC1155)]);\n    if (isERC721) {\n      const ERC721Abi = (await import('@thirdweb-dev/contracts-js/dist/abis/IERC721.json')).default;\n      const asset = new Contract(assetContract, ERC721Abi, provider);\n      const approved = await asset.isApprovedForAll(owner, transferrerContractAddress);\n      if (approved) {\n        return true;\n      }\n\n      // Handle reverts in case of non-existent tokens\n      let approvedAddress;\n      try {\n        approvedAddress = await asset.getApproved(tokenId);\n      } catch (e) {}\n      return approvedAddress?.toLowerCase() === transferrerContractAddress.toLowerCase();\n    } else if (isERC1155) {\n      const ERC1155Abi = (await import('@thirdweb-dev/contracts-js/dist/abis/IERC1155.json')).default;\n      const asset = new Contract(assetContract, ERC1155Abi, provider);\n      return await asset.isApprovedForAll(owner, transferrerContractAddress);\n    } else {\n      console.error(\"Contract does not implement ERC 1155 or ERC 721.\");\n      return false;\n    }\n  } catch (err) {\n    console.error(\"Failed to check if token is approved\", err);\n    return false;\n  }\n}\n\n/**\n * Checks if the marketplace is approved to make transfers on the assetContract\n * If not, it tries to set the approval.\n * @param contractWrapper - The contract wrapper to use\n * @param marketplaceAddress - The address of the marketplace contract\n * @param assetContract - The address of the asset contract.\n * @param tokenId - The token id of the token.\n * @param from - The address of the account that owns the token.\n */\nasync function handleTokenApproval(contractWrapper, marketplaceAddress, assetContract, tokenId, from) {\n  const ERC165Abi = (await import('@thirdweb-dev/contracts-js/dist/abis/IERC165.json')).default;\n  const erc165 = new ContractWrapper(contractWrapper.getSignerOrProvider(), assetContract, ERC165Abi, contractWrapper.options, contractWrapper.storage);\n  const [isERC721, isERC1155] = await Promise.all([erc165.read(\"supportsInterface\", [InterfaceId_IERC721]), erc165.read(\"supportsInterface\", [InterfaceId_IERC1155])]);\n  // check for token approval\n  if (isERC721) {\n    const ERC721Abi = (await import('@thirdweb-dev/contracts-js/dist/abis/IERC721.json')).default;\n    const asset = new ContractWrapper(contractWrapper.getSignerOrProvider(), assetContract, ERC721Abi, contractWrapper.options, contractWrapper.storage);\n    const approved = await asset.read(\"isApprovedForAll\", [from, marketplaceAddress]);\n    if (!approved) {\n      const isTokenApproved = (await asset.read(\"getApproved\", [tokenId])).toLowerCase() === marketplaceAddress.toLowerCase();\n      if (!isTokenApproved) {\n        await asset.sendTransaction(\"setApprovalForAll\", [marketplaceAddress, true]);\n      }\n    }\n  } else if (isERC1155) {\n    const ERC1155Abi = (await import('@thirdweb-dev/contracts-js/dist/abis/IERC1155.json')).default;\n    const asset = new ContractWrapper(contractWrapper.getSignerOrProvider(), assetContract, ERC1155Abi, contractWrapper.options, contractWrapper.storage);\n    const approved = await asset.read(\"isApprovedForAll\", [from, marketplaceAddress]);\n    if (!approved) {\n      await asset.sendTransaction(\"setApprovalForAll\", [marketplaceAddress, true]);\n    }\n  } else {\n    throw Error(\"Contract must implement ERC 1155 or ERC 721.\");\n  }\n}\n\n/**\n * Used to verify fields in new listing.\n * @internal\n */\n// TODO this should be done in zod\nfunction validateNewListingParam(param) {\n  invariant(param.assetContractAddress !== undefined && param.assetContractAddress !== null, \"Asset contract address is required\");\n  invariant(param.buyoutPricePerToken !== undefined && param.buyoutPricePerToken !== null, \"Buyout price is required\");\n  invariant(param.listingDurationInSeconds !== undefined && param.listingDurationInSeconds !== null, \"Listing duration is required\");\n  invariant(param.startTimestamp !== undefined && param.startTimestamp !== null, \"Start time is required\");\n  invariant(param.tokenId !== undefined && param.tokenId !== null, \"Token ID is required\");\n  invariant(param.quantity !== undefined && param.quantity !== null, \"Quantity is required\");\n  switch (param.type) {\n    case \"NewAuctionListing\":\n      {\n        invariant(param.reservePricePerToken !== undefined && param.reservePricePerToken !== null, \"Reserve price is required\");\n      }\n  }\n}\n\n/**\n * Maps a contract offer to the strict interface\n *\n * @internal\n * @param offer - The offer to map\n * @returns  An `Offer` object\n */\nasync function mapOffer(provider, listingId, offer) {\n  return {\n    quantity: offer.quantityDesired,\n    pricePerToken: offer.pricePerToken,\n    currencyContractAddress: offer.currency,\n    buyerAddress: offer.offeror,\n    quantityDesired: offer.quantityWanted,\n    currencyValue: await fetchCurrencyValue(provider, offer.currency, offer.quantityWanted.mul(offer.pricePerToken)),\n    listingId\n  };\n}\nfunction isWinningBid(winningPrice, newBidPrice, bidBuffer) {\n  bidBuffer = BigNumber.from(bidBuffer);\n  winningPrice = BigNumber.from(winningPrice);\n  newBidPrice = BigNumber.from(newBidPrice);\n  if (winningPrice.eq(BigNumber.from(0))) {\n    return false;\n  }\n  const buffer = newBidPrice.sub(winningPrice).mul(MAX_BPS).div(winningPrice);\n  return buffer.gte(bidBuffer);\n}\nasync function getAllInBatches(start, end, fn) {\n  const batches = [];\n  while (end - start > DEFAULT_QUERY_ALL_COUNT) {\n    batches.push(fn(start, start + DEFAULT_QUERY_ALL_COUNT - 1));\n    start += DEFAULT_QUERY_ALL_COUNT;\n  }\n  batches.push(fn(start, end - 1));\n  return await Promise.all(batches);\n}\n\nexport { isWinningBid as a, getAllInBatches as g, handleTokenApproval as h, isTokenApprovedForTransfer as i, mapOffer as m, validateNewListingParam as v };\n","import { cs as ContractWrapper } from './index-33cd3415.browser.esm.js';\n\n/**\n * @internal\n */\nasync function hasERC20Allowance(contractToApprove, currencyAddress, value) {\n  const provider = contractToApprove.getProvider();\n  const ERC20Abi = (await import('@thirdweb-dev/contracts-js/dist/abis/IERC20.json')).default;\n  const erc20 = new ContractWrapper(provider, currencyAddress, ERC20Abi, {}, contractToApprove.storage);\n  const owner = await contractToApprove.getSignerAddress();\n  const spender = contractToApprove.address;\n  const allowance = await erc20.read(\"allowance\", [owner, spender]);\n  return allowance.gte(value);\n}\n\nexport { hasERC20Allowance as h };\n"],"names":["Multiwrap","StandardErc721","static","MULTIWRAP_CONTRACT_ROLES","constructor","network","address","storage","options","arguments","length","undefined","abi","chainId","super","ContractWrapper","this","AbiSchema","parse","metadata","ContractMetadata","contractWrapper","MultiwrapContractSchema","app","ContractAppURI","roles","ContractRoles","contractRoles","encoder","ContractEncoder","estimator","GasCostEstimator","events","ContractEvents","royalties","ContractRoyalty","owner","ContractOwner","getWrappedContents","wrappedTokenId","wrappedTokens","read","erc20Tokens","erc721Tokens","erc1155Tokens","token","tokenType","tokenMetadata","fetchCurrencyMetadata","getProvider","assetContract","push","contractAddress","quantity","utils","totalAmount","decimals","tokenId","toString","wrap","buildTransactionFunction","async","contents","wrappedTokenMetadata","recipientAddress","uri","tokens","recipient","Promise","all","uploadOrExtractURI","toTokenStructList","resolveAddress","getSignerAddress","Transaction","fromContractWrapper","method","args","receipt","event","parseLogs","logs","Error","tokenIdOfWrappedToken","id","data","get","unwrap","provider","erc20","normalizedQuantity","normalizePriceValue","hasERC20Allowance","getAddress","erc721","isTokenApprovedForTransfer","erc1155","prepare","overrides","call","functionName","_chainId","Erc721","onNetworkUpdated","updateSignerOrProvider","getAll","queryParams","getOwned","walletAddress","getOwnedTokenIds","totalSupply","totalCirculatingSupply","ownerOf","balanceOf","balance","isApproved","operator","transfer","to","setApprovalForAll","approved","setApprovalForToken","transferrerContractAddress","ERC165Abi","default","erc165","Contract","isERC721","isERC1155","supportsInterface","InterfaceId_IERC721","InterfaceId_IERC1155","ERC721Abi","asset","isApprovedForAll","approvedAddress","getApproved","e","toLowerCase","ERC1155Abi","console","error","err","handleTokenApproval","marketplaceAddress","from","getSignerOrProvider","sendTransaction","validateNewListingParam","param","invariant","assetContractAddress","buyoutPricePerToken","listingDurationInSeconds","startTimestamp","type","reservePricePerToken","mapOffer","listingId","offer","quantityDesired","pricePerToken","currencyContractAddress","currency","buyerAddress","offeror","quantityWanted","currencyValue","fetchCurrencyValue","mul","isWinningBid","winningPrice","newBidPrice","bidBuffer","BigNumber","eq","sub","MAX_BPS","div","gte","getAllInBatches","start","end","fn","batches","DEFAULT_QUERY_ALL_COUNT","contractToApprove","currencyAddress","value","ERC20Abi","spender"],"sourceRoot":""}