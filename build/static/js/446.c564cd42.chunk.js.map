{"version":3,"file":"static/js/446.c564cd42.chunk.js","mappings":"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","sources":["../node_modules/@thirdweb-dev/wallets/evm/connectors/wallet-connect/dist/thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm.js","../node_modules/@thirdweb-dev/wallets/dist/errors-9edc08c8.browser.esm.js","../node_modules/@thirdweb-dev/wallets/dist/WagmiConnector-2f14002d.browser.esm.js"],"sourcesContent":["import { _ as _defineProperty } from '../../../../dist/defineProperty-350fc508.browser.esm.js';\nimport { U as UserRejectedRequestError, S as SwitchChainError } from '../../../../dist/errors-9edc08c8.browser.esm.js';\nimport { utils, providers } from 'ethers';\nimport { w as walletIds } from '../../../../dist/walletIds-dff6dced.browser.esm.js';\nimport { g as getValidPublicRPCUrl } from '../../../../dist/url-a45219bd.browser.esm.js';\nimport { W as WagmiConnector } from '../../../../dist/WagmiConnector-2f14002d.browser.esm.js';\nimport '@thirdweb-dev/chains';\nimport 'eventemitter3';\n\nconst chainsToRequest = new Set([1, 137, 10, 42161, 56]);\nconst NAMESPACE = \"eip155\";\nconst REQUESTED_CHAINS_KEY = \"wagmi.requestedChains\";\nconst ADD_ETH_CHAIN_METHOD = \"wallet_addEthereumChain\";\nconst LAST_USED_CHAIN_ID = \"last-used-chain-id\";\nclass WalletConnectConnector extends WagmiConnector {\n  constructor(config) {\n    super({\n      ...config,\n      options: {\n        isNewChainsStale: true,\n        ...config.options\n      }\n    });\n    _defineProperty(this, \"id\", walletIds.walletConnect);\n    _defineProperty(this, \"name\", \"WalletConnect\");\n    _defineProperty(this, \"ready\", true);\n    _defineProperty(this, \"onAccountsChanged\", accounts => {\n      if (accounts.length === 0) {\n        this.emit(\"disconnect\");\n      } else {\n        if (accounts[0]) {\n          this.emit(\"change\", {\n            account: utils.getAddress(accounts[0])\n          });\n        }\n      }\n    });\n    _defineProperty(this, \"onChainChanged\", async chainId => {\n      const id = Number(chainId);\n      const unsupported = this.isChainUnsupported(id);\n      await this._storage.setItem(LAST_USED_CHAIN_ID, String(chainId));\n      this.emit(\"change\", {\n        chain: {\n          id,\n          unsupported\n        }\n      });\n    });\n    _defineProperty(this, \"onDisconnect\", async () => {\n      await this._setRequestedChainsIds([]);\n      await this._storage.removeItem(LAST_USED_CHAIN_ID);\n      this.emit(\"disconnect\");\n    });\n    _defineProperty(this, \"onDisplayUri\", uri => {\n      this.emit(\"message\", {\n        type: \"display_uri\",\n        data: uri\n      });\n    });\n    _defineProperty(this, \"onConnect\", () => {\n      this.emit(\"connect\", {\n        provider: this._provider\n      });\n    });\n    this._storage = config.options.storage;\n    this._createProvider();\n    this.filteredChains = this.chains.length > 50 ? this.chains.filter(c => {\n      return chainsToRequest.has(c.chainId);\n    }) : this.chains;\n    this.showWalletConnectModal = this.options.qrcode !== false;\n  }\n  async connect() {\n    let {\n      chainId: chainIdP,\n      pairingTopic\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    try {\n      let targetChainId = chainIdP;\n      if (!targetChainId) {\n        const lastUsedChainIdStr = await this._storage.getItem(LAST_USED_CHAIN_ID);\n        const lastUsedChainId = lastUsedChainIdStr ? parseInt(lastUsedChainIdStr) : undefined;\n        if (lastUsedChainId && !this.isChainUnsupported(lastUsedChainId)) {\n          targetChainId = lastUsedChainId;\n        } else {\n          targetChainId = this.filteredChains[0]?.chainId;\n        }\n      }\n      if (!targetChainId) {\n        throw new Error(\"No chains found on connector.\");\n      }\n      const provider = await this.getProvider();\n      this.setupListeners();\n      if (provider.session) {\n        await provider.disconnect();\n        const optionalChains = this.filteredChains.filter(chain => chain.chainId !== targetChainId).map(optionalChain => optionalChain.chainId);\n        this.emit(\"message\", {\n          type: \"connecting\"\n        });\n        await provider.connect({\n          pairingTopic,\n          chains: [targetChainId],\n          optionalChains: optionalChains.length > 0 ? optionalChains : [targetChainId]\n        });\n        await this._setRequestedChainsIds(this.filteredChains.map(_ref => {\n          let {\n            chainId\n          } = _ref;\n          return chainId;\n        }));\n      }\n\n      // If session exists and chains are authorized, enable provider for required chain\n      const accounts = await provider.enable();\n      if (!accounts[0]) {\n        throw new Error(\"No accounts found on provider.\");\n      }\n      const account = utils.getAddress(accounts[0]);\n      const id = await this.getChainId();\n      const unsupported = this.isChainUnsupported(id);\n      return {\n        account,\n        chain: {\n          id,\n          unsupported\n        },\n        provider: new providers.Web3Provider(provider)\n      };\n    } catch (error) {\n      if (/user rejected/i.test(error?.message)) {\n        throw new UserRejectedRequestError(error);\n      }\n      throw error;\n    }\n  }\n  async disconnect() {\n    const cleanup = () => {\n      if (typeof localStorage === \"undefined\") {\n        return;\n      }\n      for (const key in localStorage) {\n        if (key.startsWith(\"wc@2\")) {\n          localStorage.removeItem(key);\n        }\n      }\n    };\n    cleanup();\n    const provider = await this.getProvider();\n    const disconnectProvider = async () => {\n      try {\n        await provider.disconnect();\n      } catch (error) {\n        if (!/No matching key/i.test(error.message)) {\n          throw error;\n        }\n      } finally {\n        this._removeListeners();\n        await this._setRequestedChainsIds([]);\n        cleanup();\n      }\n    };\n    disconnectProvider();\n  }\n  async getAccount() {\n    const {\n      accounts\n    } = await this.getProvider();\n    if (!accounts[0]) {\n      throw new Error(\"No accounts found on provider.\");\n    }\n    return utils.getAddress(accounts[0]);\n  }\n  async getChainId() {\n    const {\n      chainId\n    } = await this.getProvider();\n    return chainId;\n  }\n  async getProvider() {\n    let {\n      chainId\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (!this._provider) {\n      await this._createProvider();\n    }\n    if (chainId) {\n      await this.switchChain(chainId);\n    }\n    if (!this._provider) {\n      throw new Error(\"No provider found.\");\n    }\n    return this._provider;\n  }\n  async getSigner() {\n    let {\n      chainId\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const [provider, account] = await Promise.all([this.getProvider({\n      chainId\n    }), this.getAccount()]);\n    return new providers.Web3Provider(provider, chainId).getSigner(account);\n  }\n  async isAuthorized() {\n    try {\n      const [account, provider] = await Promise.all([this.getAccount(), this.getProvider()]);\n      const isChainsStale = await this._isChainsStale();\n\n      // If an account does not exist on the session, then the connector is unauthorized.\n      if (!account) {\n        return false;\n      }\n\n      // If the chains are stale on the session, then the connector is unauthorized.\n      if (isChainsStale && provider.session) {\n        try {\n          await provider.disconnect();\n        } catch {} // eslint-disable-line no-empty\n        return false;\n      }\n      return true;\n    } catch {\n      return false;\n    }\n  }\n  async switchChain(chainId) {\n    const chain = this.chains.find(chain_ => chain_.chainId === chainId);\n    if (!chain) {\n      throw new SwitchChainError(`Chain with ID: ${chainId}, not found on connector.`);\n    }\n    try {\n      const provider = await this.getProvider();\n      const namespaceChains = this._getNamespaceChainsIds();\n      const namespaceMethods = this._getNamespaceMethods();\n      const isChainApproved = namespaceChains.includes(chainId);\n      if (!isChainApproved && namespaceMethods.includes(ADD_ETH_CHAIN_METHOD)) {\n        const firstExplorer = chain.explorers && chain.explorers[0];\n        const blockExplorerUrls = firstExplorer ? {\n          blockExplorerUrls: [firstExplorer.url]\n        } : {};\n        await provider.request({\n          method: ADD_ETH_CHAIN_METHOD,\n          params: [{\n            chainId: utils.hexValue(chain.chainId),\n            chainName: chain.name,\n            nativeCurrency: chain.nativeCurrency,\n            rpcUrls: getValidPublicRPCUrl(chain),\n            // no clientId on purpose\n            ...blockExplorerUrls\n          }]\n        });\n        const requestedChains = await this._getRequestedChainsIds();\n        requestedChains.push(chainId);\n        await this._setRequestedChainsIds(requestedChains);\n      }\n      await provider.request({\n        method: \"wallet_switchEthereumChain\",\n        params: [{\n          chainId: utils.hexValue(chainId)\n        }]\n      });\n      return chain;\n    } catch (error) {\n      const message = typeof error === \"string\" ? error : error?.message;\n      if (/user rejected request/i.test(message)) {\n        throw new UserRejectedRequestError(error);\n      }\n      throw new SwitchChainError(error);\n    }\n  }\n  async _createProvider() {\n    if (!this._initProviderPromise && \"object\" !== \"undefined\") {\n      this._initProviderPromise = this.initProvider();\n    }\n    return this._initProviderPromise;\n  }\n  async initProvider() {\n    const {\n      default: EthereumProvider,\n      OPTIONAL_EVENTS,\n      OPTIONAL_METHODS\n    } = await import('@walletconnect/ethereum-provider');\n    const [defaultChain, ...optionalChains] = this.filteredChains.map(_ref2 => {\n      let {\n        chainId\n      } = _ref2;\n      return chainId;\n    });\n    if (defaultChain) {\n      // EthereumProvider populates & deduplicates required methods and events internally\n      this._provider = await EthereumProvider.init({\n        showQrModal: this.showWalletConnectModal,\n        projectId: this.options.projectId,\n        methods: [\"eth_sendTransaction\", \"personal_sign\", \"eth_signTypedData_v4\"],\n        optionalMethods: OPTIONAL_METHODS,\n        optionalEvents: OPTIONAL_EVENTS,\n        chains: [defaultChain],\n        optionalChains: optionalChains,\n        metadata: {\n          name: this.options.dappMetadata.name,\n          description: this.options.dappMetadata.description || \"\",\n          url: this.options.dappMetadata.url,\n          icons: [this.options.dappMetadata.logoUrl || \"\"]\n        },\n        rpcMap: Object.fromEntries(this.filteredChains.map(chain => [chain.chainId, chain.rpc[0] || \"\" // TODO: handle chain.rpc being empty array\n        ])),\n        qrModalOptions: this.options.qrModalOptions\n      });\n    }\n  }\n\n  /**\n   * Checks if the target chains match the chains that were\n   * initially requested by the connector for the WalletConnect session.\n   * If there is a mismatch, this means that the chains on the connector\n   * are considered stale, and need to be revalidated at a later point (via\n   * connection).\n   *\n   * There may be a scenario where a dapp adds a chain to the\n   * connector later on, however, this chain will not have been approved or rejected\n   * by the wallet. In this case, the chain is considered stale.\n   *\n   * There are exceptions however:\n   * -  If the wallet supports dynamic chain addition via `eth_addEthereumChain`,\n   *    then the chain is not considered stale.\n   * -  If the `isNewChainsStale` flag is falsy on the connector, then the chain is\n   *    not considered stale.\n   *\n   * For the above cases, chain validation occurs dynamically when the user\n   * attempts to switch chain.\n   *\n   * Also check that dapp supports at least 1 chain from previously approved session.\n   */\n  async _isChainsStale() {\n    const namespaceMethods = this._getNamespaceMethods();\n    if (namespaceMethods.includes(ADD_ETH_CHAIN_METHOD)) {\n      return false;\n    }\n    if (!this.options.isNewChainsStale) {\n      return false;\n    }\n    const requestedChains = await this._getRequestedChainsIds();\n    const connectorChains = this.filteredChains.map(_ref3 => {\n      let {\n        chainId\n      } = _ref3;\n      return chainId;\n    });\n    const namespaceChains = this._getNamespaceChainsIds();\n    if (namespaceChains.length && !namespaceChains.some(id => connectorChains.includes(id))) {\n      return false;\n    }\n    return !connectorChains.every(id => requestedChains.includes(id));\n  }\n  async setupListeners() {\n    if (!this._provider) {\n      return;\n    }\n    this._removeListeners();\n    this._provider.on(\"accountsChanged\", this.onAccountsChanged);\n    this._provider.on(\"chainChanged\", this.onChainChanged);\n    this._provider.on(\"disconnect\", this.onDisconnect);\n    this._provider.on(\"session_delete\", this.onDisconnect);\n    this._provider.on(\"display_uri\", this.onDisplayUri);\n    this._provider.on(\"connect\", this.onConnect);\n  }\n  _removeListeners() {\n    if (!this._provider) {\n      return;\n    }\n    this._provider.removeListener(\"accountsChanged\", this.onAccountsChanged);\n    this._provider.removeListener(\"chainChanged\", this.onChainChanged);\n    this._provider.removeListener(\"disconnect\", this.onDisconnect);\n    this._provider.removeListener(\"session_delete\", this.onDisconnect);\n    this._provider.removeListener(\"display_uri\", this.onDisplayUri);\n    this._provider.removeListener(\"connect\", this.onConnect);\n  }\n  async _setRequestedChainsIds(chains) {\n    await this._storage.setItem(REQUESTED_CHAINS_KEY, JSON.stringify(chains));\n  }\n  async _getRequestedChainsIds() {\n    const data = await this._storage.getItem(REQUESTED_CHAINS_KEY);\n    return data ? JSON.parse(data) : [];\n  }\n  _getNamespaceChainsIds() {\n    if (!this._provider) {\n      return [];\n    }\n    const chainIds = this._provider.session?.namespaces[NAMESPACE]?.chains?.map(chain => parseInt(chain.split(\":\")[1] || \"\"));\n    return chainIds ?? [];\n  }\n  _getNamespaceMethods() {\n    if (!this._provider) {\n      return [];\n    }\n    const methods = this._provider.session?.namespaces[NAMESPACE]?.methods;\n    return methods ?? [];\n  }\n}\n\nexport { WalletConnectConnector };\n","import { _ as _defineProperty } from './defineProperty-350fc508.browser.esm.js';\n\n/**\n * Error subclass implementing JSON RPC 2.0 errors and Ethereum RPC errors per EIP-1474.\n * @see https://eips.ethereum.org/EIPS/eip-1474\n */\nclass RpcError extends Error {\n  constructor( /** Human-readable string */\n  message, options) {\n    const {\n      cause,\n      code,\n      data\n    } = options;\n    if (!Number.isInteger(code)) {\n      throw new Error('\"code\" must be an integer.');\n    }\n    if (!message || typeof message !== \"string\") {\n      throw new Error('\"message\" must be a nonempty string.');\n    }\n    super(`${message}. Cause: ${JSON.stringify(cause)}`);\n    this.cause = cause;\n    this.code = code;\n    this.data = data;\n  }\n}\n\n/**\n * @internal\n * Error subclass implementing Ethereum Provider errors per EIP-1193.\n * @see https://eips.ethereum.org/EIPS/eip-1193\n */\nclass ProviderRpcError extends RpcError {\n  /**\n   * Create an Ethereum Provider JSON-RPC error.\n   * `code` must be an integer in the `1000 <= 4999` range.\n   */\n  constructor( /** Human-readable string */\n  message, options) {\n    const {\n      cause,\n      code,\n      data\n    } = options;\n    if (!(Number.isInteger(code) && code >= 1000 && code <= 4999)) {\n      throw new Error('\"code\" must be an integer such that: 1000 <= code <= 4999');\n    }\n    super(message, {\n      cause,\n      code,\n      data\n    });\n  }\n}\n\n/**\n * @internal\n */\nclass AddChainError extends Error {\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"name\", \"AddChainError\");\n    _defineProperty(this, \"message\", \"Error adding chain\");\n  }\n}\n\n/**\n * @internal\n */\nclass ChainNotConfiguredError extends Error {\n  constructor(_ref) {\n    let {\n      chainId,\n      connectorId\n    } = _ref;\n    super(`Chain \"${chainId}\" not configured for connector \"${connectorId}\".`);\n    _defineProperty(this, \"name\", \"ChainNotConfigured\");\n  }\n}\nclass ConnectorNotFoundError extends Error {\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"name\", \"ConnectorNotFoundError\");\n    _defineProperty(this, \"message\", \"Connector not found\");\n  }\n}\nclass ResourceUnavailableError extends RpcError {\n  constructor(cause) {\n    super(\"Resource unavailable\", {\n      cause,\n      code: -32002\n    });\n    _defineProperty(this, \"name\", \"ResourceUnavailable\");\n  }\n}\n/**\n * @internal\n */\nclass SwitchChainError extends ProviderRpcError {\n  constructor(cause) {\n    super(\"Error switching chain\", {\n      cause,\n      code: 4902\n    });\n    _defineProperty(this, \"name\", \"SwitchChainError\");\n  }\n}\n/**\n * @internal\n */\nclass UserRejectedRequestError extends ProviderRpcError {\n  constructor(cause) {\n    super(\"User rejected request\", {\n      cause,\n      code: 4001\n    });\n    _defineProperty(this, \"name\", \"UserRejectedRequestError\");\n  }\n}\n\n/**\n * @internal\n */\n// Ethers does not have an error type so we can use this for casting\n// https://github.com/ethers-io/ethers.js/blob/main/packages/logger/src.ts/index.ts#L268\n\nexport { AddChainError as A, ChainNotConfiguredError as C, ProviderRpcError as P, ResourceUnavailableError as R, SwitchChainError as S, UserRejectedRequestError as U, ConnectorNotFoundError as a };\n","import { defaultChains } from '@thirdweb-dev/chains';\nimport EventEmitter from 'eventemitter3';\n\nclass WagmiConnector extends EventEmitter {\n  /** Unique connector id */\n\n  /** Connector name */\n\n  /** Chains connector supports */\n\n  /** Options to use with connector */\n\n  /** Whether connector is usable */\n\n  constructor(_ref) {\n    let {\n      chains = defaultChains,\n      options\n    } = _ref;\n    super();\n    this.chains = chains;\n    this.options = options;\n  }\n  getBlockExplorerUrls(chain) {\n    const explorers = chain.explorers?.map(x => x.url) ?? [];\n    return explorers.length > 0 ? explorers : undefined;\n  }\n  isChainUnsupported(chainId) {\n    return !this.chains.some(x => x.chainId === chainId);\n  }\n  updateChains(chains) {\n    this.chains = chains;\n  }\n}\n\nexport { WagmiConnector as W };\n"],"names":["chainsToRequest","Set","NAMESPACE","REQUESTED_CHAINS_KEY","ADD_ETH_CHAIN_METHOD","LAST_USED_CHAIN_ID","WalletConnectConnector","WagmiConnector","constructor","config","super","options","isNewChainsStale","_defineProperty","this","walletIds","walletConnect","accounts","length","emit","account","utils","async","id","Number","chainId","unsupported","isChainUnsupported","_storage","setItem","String","chain","_setRequestedChainsIds","removeItem","uri","type","data","provider","_provider","storage","_createProvider","filteredChains","chains","filter","c","has","showWalletConnectModal","qrcode","connect","chainIdP","pairingTopic","arguments","undefined","targetChainId","lastUsedChainIdStr","getItem","lastUsedChainId","parseInt","Error","getProvider","setupListeners","session","disconnect","optionalChains","map","optionalChain","_ref","enable","getChainId","providers","error","test","message","UserRejectedRequestError","cleanup","localStorage","key","startsWith","_removeListeners","disconnectProvider","getAccount","switchChain","getSigner","Promise","all","isAuthorized","isChainsStale","_isChainsStale","find","chain_","SwitchChainError","namespaceChains","_getNamespaceChainsIds","namespaceMethods","_getNamespaceMethods","includes","firstExplorer","explorers","blockExplorerUrls","url","request","method","params","chainName","name","nativeCurrency","rpcUrls","getValidPublicRPCUrl","requestedChains","_getRequestedChainsIds","push","_initProviderPromise","initProvider","default","EthereumProvider","OPTIONAL_EVENTS","OPTIONAL_METHODS","defaultChain","_ref2","init","showQrModal","projectId","methods","optionalMethods","optionalEvents","metadata","dappMetadata","description","icons","logoUrl","rpcMap","Object","fromEntries","rpc","qrModalOptions","connectorChains","_ref3","some","every","on","onAccountsChanged","onChainChanged","onDisconnect","onDisplayUri","onConnect","removeListener","JSON","stringify","parse","chainIds","namespaces","split","RpcError","cause","code","isInteger","ProviderRpcError","AddChainError","ChainNotConfiguredError","connectorId","ConnectorNotFoundError","ResourceUnavailableError","EventEmitter","defaultChains","getBlockExplorerUrls","x","updateChains"],"sourceRoot":""}